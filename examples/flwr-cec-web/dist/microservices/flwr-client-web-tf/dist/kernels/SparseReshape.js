/*! For license information please see SparseReshape.js.LICENSE.txt */
import{backend_util,SparseReshape,util}from"@tensorflow/tfjs-core";let wasmSparseReshape;function setup(e){wasmSparseReshape=e.wasm.cwrap(SparseReshape,null,["number","number","number","number","number","number","number"])}function sparseReshape(e){const{backend:a,inputs:t}=e,{inputIndices:r,inputShape:s,newShape:p}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==p.shape.length)throw new Error(`Target shape should be a vector but received shape ${p.shape}`);const d=a.dataIdMap.get(r.dataId).id,n=a.dataIdMap.get(s.dataId).id,u=a.dataIdMap.get(p.dataId).id,i=r.shape[0],o=util.sizeFromShape(p.shape),h=a.makeOutput([i,o],r.dtype),c=a.dataIdMap.get(h.dataId).id,m=a.makeOutput([o],p.dtype),b=a.dataIdMap.get(m.dataId).id,l=a.makeOutput([3],"int32"),I=a.dataIdMap.get(l.dataId).id;wasmSparseReshape(d,n,u,i,c,b,I);const g=a.readSync(l.dataId);let S;switch(g[0]){case 0:S=backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(g[1],g[2]);break;case 1:S=backend_util.getSparseReshapeNegativeOutputDimErrorMessage(g[1],g[2]);break;case 2:S=backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const e=Array.from(a.readSync(s.dataId)),t=Array.from(a.readSync(m.dataId));S=backend_util.getSparseReshapeInputOutputMultipleErrorMessage(e,t);break}case 4:{const e=Array.from(a.readSync(s.dataId)),t=Array.from(a.readSync(m.dataId));S=backend_util.getSparseReshapeInputOutputMismatchErrorMessage(e,t);break}default:S=""}if(a.disposeData(l.dataId),S)throw a.disposeData(h.dataId),a.disposeData(m.dataId),new Error(S);return[h,m]}export const sparseReshapeConfig={kernelName:SparseReshape,backendName:"wasm",setupFunc:setup,kernelFunc:sparseReshape};
/*! For license information please see MaxPoolWithArgmax.js.LICENSE.txt */
import{backend_util,MaxPoolWithArgmax,util}from"@tensorflow/tfjs-core";import{CppDType}from"./types";let wasmMaxPoolWithArgmax;function setup(t){wasmMaxPoolWithArgmax=t.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}export function maxPoolWithArgmax(t){const{inputs:e,backend:a,attrs:i}=t,{x:n}=e,{filterSize:r,strides:o,pad:m,includeBatchInIndex:u}=i;util.assert(4===n.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`));const d=[1,1];util.assert(backend_util.eitherStridesOrDilationsAreOne(o,d),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`));const s=backend_util.computePool2DInfo(n.shape,r,o,[1,1],m),l=a.makeOutput(s.outShape,n.dtype),p=a.makeOutput(s.outShape,"int32");return wasmMaxPoolWithArgmax(a.dataIdMap.get(n.dataId).id,a.dataIdMap.get(l.dataId).id,a.dataIdMap.get(p.dataId).id,CppDType[n.dtype],u,s.batchSize,s.inChannels,s.inHeight,s.inWidth,s.outHeight,s.outWidth,s.strideHeight,s.strideWidth,s.dilationHeight,s.dilationWidth,s.effectiveFilterHeight,s.effectiveFilterWidth,s.padInfo.top,s.padInfo.left),[l,p]}export const maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"wasm",setupFunc:setup,kernelFunc:maxPoolWithArgmax};
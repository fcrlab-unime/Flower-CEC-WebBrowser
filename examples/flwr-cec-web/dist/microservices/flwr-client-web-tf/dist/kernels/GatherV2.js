/*! For license information please see GatherV2.js.LICENSE.txt */
import{backend_util,GatherV2,util}from"@tensorflow/tfjs-core";import{reshape}from"./Reshape";import{CppDType}from"./types";let wasmGather;function setup(e){wasmGather=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function gatherV2(e){const{backend:t,inputs:a,attrs:r}=e,{x:s,indices:i}=a,{axis:n,batchDims:p}=r,u=util.parseAxisParam(n,s.shape)[0],h=t.readSync(i.dataId),d=s.shape[u];for(let e=0;e<h.length;++e){const t=h[e];util.assert(t<=d-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${d-1}]`))}const c=backend_util.segment_util.collectGatherOpShapeInfo(s,i,u,p),o=reshape({inputs:{x:s},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:t}),m=util.sizeFromShape(i.shape),l=reshape({inputs:{x:i},attrs:{shape:[c.batchSize,m/c.batchSize]},backend:t}),b=[c.batchSize,c.outerSize,m/c.batchSize,c.sliceSize],S=t.makeOutput(b,s.dtype);if(0===util.sizeFromShape(s.shape))return S;const f=o.shape.length-1,z=t.dataIdMap.get(o.dataId).id,y=t.dataIdMap.get(l.dataId).id,I=t.dataIdMap.get(S.dataId).id,w=new Uint8Array(new Int32Array(util.computeStrides(o.shape)).buffer),g=new Uint8Array(new Int32Array(util.computeStrides(b)).buffer);return wasmGather(z,CppDType[s.dtype],w,f,y,c.batchSize,g,I),t.disposeData(o.dataId),t.disposeData(l.dataId),S.shape=c.outputShape,S}export const gatherV2Config={kernelName:GatherV2,backendName:"wasm",setupFunc:setup,kernelFunc:gatherV2};
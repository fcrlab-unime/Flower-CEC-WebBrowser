/*! For license information please see SparseFillEmptyRows.js.LICENSE.txt */
import{backend_util,SparseFillEmptyRows}from"@tensorflow/tfjs-core";import{slice}from"./Slice";import{CppDType}from"./types";let wasmSparseFillEmptyRows;export function setup(a){wasmSparseFillEmptyRows=a.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}export function sparseFillEmptyRows(a){const{backend:e,inputs:t}=a,{indices:d,values:s,denseShape:p,defaultValue:r}=t,i=d.shape[0],n=d.shape[1],l=e.readSync(p.dataId)[0],m=[i+l,n],u=e.dataIdMap.get(d.dataId).id,o=e.dataIdMap.get(s.dataId).id,c=e.dataIdMap.get(r.dataId).id,I=e.makeOutput(m,d.dtype),b=e.dataIdMap.get(I.dataId).id,w=e.makeOutput(m.slice(0,1),s.dtype),y=e.dataIdMap.get(w.dataId).id,g=e.makeOutput([l],"bool"),k=e.dataIdMap.get(g.dataId).id,E=e.makeOutput([i],d.dtype),F=e.dataIdMap.get(E.dataId).id,S=e.makeOutput([4],"int32"),R=e.dataIdMap.get(S.dataId).id,f=wasmSparseFillEmptyRows(u,o,CppDType[s.dtype],i,l,n,c,b,y,k,F,R),M=e.readSync(S.dataId);let D;switch(M[0]){case 1:D=backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(M[1]);break;case 2:D=backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(M[1],M[2]);break;case 3:D=backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(M[1],M[2],M[3]);break;default:D=""}if(e.disposeData(S.dataId),D)throw e.disposeData(I.dataId),e.disposeData(w.dataId),e.disposeData(g.dataId),e.disposeData(E.dataId),new Error(D);let h=I,x=w;return f!==m[0]&&(h=slice({inputs:{x:I},attrs:{begin:0,size:[f,n]},backend:e}),x=slice({inputs:{x:w},attrs:{begin:0,size:f},backend:e}),e.disposeData(I.dataId),e.disposeData(w.dataId)),[h,x,g,E]}export const sparseFillEmptyRowsConfig={kernelName:SparseFillEmptyRows,backendName:"wasm",setupFunc:setup,kernelFunc:sparseFillEmptyRows};
/*! For license information please see Concat.js.LICENSE.txt */
import{backend_util,Concat,util}from"@tensorflow/tfjs-core";import{concatImplCPU}from"../kernel_utils/shared";import{identity}from"./Identity";import{reshape}from"./Reshape";export function concat(t){const{inputs:e,backend:a}=t,s=util.parseAxisParam(t.attrs.axis,e[0].shape)[0],r=e.map((t=>t.shape));backend_util.assertParamsConsistent(r,s);let p=backend_util.computeOutShape(e.map((t=>t.shape)),s);const n=e.filter((t=>util.sizeFromShape(t.shape)>0));if(1===n.length)return identity({inputs:{x:n[0]},backend:a});const o=a.makeOutput(p,e[0].dtype);if(0===util.sizeFromShape(p))return o;if("string"===n[0].dtype){const t=n.map((t=>{const e=util.sizeFromShape(t.shape.slice(s));return reshape({inputs:{x:t},backend:a,attrs:{shape:[-1,e]}})})),r=t.map((t=>({vals:a.readSync(t.dataId),shape:t.shape})));p=backend_util.computeOutShape(t.map((t=>t.shape)),1);const i=1===t[0].shape[0],c=concatImplCPU(r,p,e[0].dtype,i),m=backend_util.computeOutShape(n.map((t=>t.shape)),s);return o.shape=m,a.dataIdMap.get(o.dataId).stringBytes=backend_util.fromStringArrayToUint8(c),t.forEach((t=>a.disposeData(t.dataId))),o}const i=util.sizeFromShape(n[0].shape.slice(0,s));let c=0;const m=n.map((t=>{const e=util.sizeFromShape(t.shape.slice(s));return c+=e,e})),u=n.map((t=>a.typedArrayFromHeap(t))),l=a.typedArrayFromHeap(o);for(let t=0;t<i;t++){let e=t*c;for(let a=0;a<u.length;a++){const s=m[a],r=t*s,p=u[a].subarray(r,r+s);l.set(p,e),e+=s}}return o}export const concatConfig={kernelName:Concat,backendName:"wasm",kernelFunc:concat};
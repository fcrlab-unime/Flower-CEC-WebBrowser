/*! For license information please see SparseSegmentReduction.js.LICENSE.txt */
import{backend_util}from"@tensorflow/tfjs-core";import{CppDType}from"./types";let wasmSparseSegmentReduction;export function setup(e){wasmSparseSegmentReduction=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}export function sparseSegmentReduction(e,t){const{backend:a,inputs:d}=e,{data:n,indices:r,segmentIds:s}=d,i=r.shape[0],p=a.readSync(s.dataId,i-1,i)[0],u=i>0?p+1:0;if(u<0)throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const o=n.shape.slice();o[0]=u;const c=a.dataIdMap.get(n.dataId).id,g=a.dataIdMap.get(r.dataId).id,m=a.dataIdMap.get(s.dataId).id,S=a.makeOutput(o,n.dtype),I=a.dataIdMap.get(S.dataId).id,b=a.makeOutput([4],"int32"),k=a.dataIdMap.get(b.dataId).id;wasmSparseSegmentReduction(c,CppDType[n.dtype],n.shape[0],g,m,I,k,t,0);const l=a.readSync(b.dataId);let R;switch(l[0]){case 0:R=backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:R=backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:R=backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(l[1],l[2]);break;case 3:R=backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(l[1],l[2],l[3]);break;default:R=""}if(a.disposeData(b.dataId),R)throw a.disposeData(S.dataId),new Error(R);return S}
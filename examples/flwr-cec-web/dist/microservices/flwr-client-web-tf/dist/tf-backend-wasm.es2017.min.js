/*! For license information please see tf-backend-wasm.es2017.min.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core"),require("fs"),require("path"),require("perf_hooks"),require("os")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","fs","path","perf_hooks","os"],t):t(((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf.wasm=e.tf.wasm||{}),e.tf,e.fs,e.path,e.perf_hooks,e.require$$4)}(this,(function(e,t,n,a,r,u){"use strict";function i(e,t){return t.forEach((function(t){t&&"string"!=typeof t&&!Array.isArray(t)&&Object.keys(t).forEach((function(n){if("default"!==n&&!(n in e)){var a=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,a.get?a:{enumerable:!0,get:function(){return t[n]}})}}))})),e}var s,o;let d;!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(s||(s={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(o||(o={}));const l={kernelName:t._FusedMatMul,backendName:"wasm",setupFunc:function(e){d=e.wasm.cwrap(t._FusedMatMul,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{a:u,b:i,bias:s,preluActivationWeights:l}=n;if("float32"!==u.dtype||"float32"!==i.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:p,transposeB:c,activation:m,leakyreluAlpha:f}=r,h=a.dataIdMap.get(u.dataId).id,b=a.dataIdMap.get(i.dataId).id;let _=0;if(null!=s){const e=a.dataIdMap.get(s.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);_=e.id}const y=null==l?0:a.dataIdMap.get(l.dataId).id,g=o[m];if(null==g)throw new Error(`${m} activation not yet supported for FusedConv2D in the wasm backend.`);const k=p?u.shape[2]:u.shape[1],I=c?i.shape[1]:i.shape[2],w=t.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0,-2),i.shape.slice(0,-2)),M=a.makeOutput([...w,k,I],u.dtype),S=a.dataIdMap.get(M.dataId).id,A=new Uint8Array(new Int32Array(u.shape).buffer),v=new Uint8Array(new Int32Array(i.shape).buffer);return d(h,A,u.shape.length,b,v,i.shape.length,p,c,g,_,y,f||0,S),M}};function p(e,n){let a;return{kernelName:e,backendName:"wasm",setupFunc:function(t){a=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){const{backend:r,inputs:{x:u}}=e,i=r.dataIdMap.get(u.dataId).id,o=r.makeOutput(u.shape,n||u.dtype),d=r.dataIdMap.get(o.dataId).id;return 0===t.util.sizeFromShape(o.shape)||a(i,s[u.dtype],d),o}}}const c=p(t.Abs),m=p(t.Acos),f=p(t.Acosh);function h(e,n,a){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:u}=e,{a:i,b:o}=u,d=n.dataIdMap.get(i.dataId).id,l=n.dataIdMap.get(o.dataId).id,p=null!=a?a:i.dtype,c=t.backend_util.assertAndGetBroadcastShape(i.shape,o.shape),m=n.makeOutput(c,p);if(0===t.util.sizeFromShape(c))return m;const f=new Uint8Array(new Int32Array(i.shape).buffer),h=new Uint8Array(new Int32Array(o.shape).buffer),b=n.dataIdMap.get(m.dataId).id;return r(d,f,i.shape.length,l,h,o.shape.length,s[i.dtype],b),m}}}const b=h(t.Add);let _;const y={kernelName:t.AddN,backendName:"wasm",setupFunc:function(e){_=e.wasm.cwrap(t.AddN,null,["array","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a}=e,r=a.makeOutput(n[0].shape,n[0].dtype);if(0===t.util.sizeFromShape(r.shape))return r;const u=n.map((e=>a.dataIdMap.get(e.dataId).id)),i=new Uint8Array(new Int32Array(u).buffer),o=a.dataIdMap.get(r.dataId).id;return _(i,u.length,s[r.dtype],o),r}};function g(e){const{inputs:{x:n},backend:a}=e;if("string"===n.dtype)return t.tensor(a.readSync(n.dataId),n.shape,n.dtype);const r=a.makeOutput(n.shape,n.dtype),u=a.typedArrayFromHeap(n);return a.typedArrayFromHeap(r).set(u),r}const k={kernelName:t.Identity,backendName:"wasm",kernelFunc:g};let I;function w(e){const{inputs:t,backend:n,attrs:a}=e,[r,u]=function(e,t){const n=[],a=[];for(let r=0;r<e.length;++r)1!==e[r]&&n.push(e[r]),1!==e[t[r]]&&a.push(t[r]);for(let e=0;e<a.length;++e){let t=-1;for(let n=0;n<a.length;++n)a[n]>=e&&(-1===t||a[t]>a[n])&&(t=n);a[t]=e}return[n,a]}(t.x.shape,a.perm);let i=!0;for(let e=0;e<u.length;e++)u[e]!==e&&(i=!1);const o=function(e,t){const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}(t.x.shape,a.perm),d={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){const e=g({inputs:t,backend:n});return e.shape=o,e}const l=n.makeOutput(o,d.dtype),p=n.dataIdMap.get(d.dataId).id,c=n.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(u).buffer),f=new Uint8Array(new Int32Array(d.shape).buffer);return I(p,f,d.shape.length,s[d.dtype],c,m,u.length),l}const M={kernelName:t.Transpose,backendName:"wasm",kernelFunc:w,setupFunc:function(e){I=e.wasm.cwrap(t.Transpose,null,["number","array","number","number","number","array","number"])}};function S(e,n,a){const r=e.shape,u=e.shape.length,i=t.util.parseAxisParam(n,r);let s=i;const o=t.backend_util.getAxesPermutation(s,u);let d=null,l=!1;if(null!=o){const n=new Array(u);for(let e=0;e<n.length;e++)n[e]=r[o[e]];s=t.backend_util.getInnerMostAxes(s.length,u),d=w({inputs:{x:e},attrs:{perm:o},backend:a});const i=a.dataIdMap.get(e.dataId).id;a.dataIdMap.get(d.dataId).id!==i&&(l=!0)}return{transposed:d,originalAxes:i,axes:s,inputWasTransposed:l}}let A;const v={kernelName:t.All,backendName:"wasm",setupFunc:function(e){A=e.wasm.cwrap(t.All,null,["number, number, number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:u,keepDims:i}=r,{x:s}=a;let o=n.dataIdMap.get(s.dataId).id,d=s;const{transposed:l,axes:p,originalAxes:c,inputWasTransposed:m}=S(s,u,n);m&&(d=l,o=n.dataIdMap.get(l.dataId).id);const f=d.shape.length;t.backend_util.assertAxesAreInnerMostDims("all",p,f);const[h,b]=t.backend_util.computeOutAndReduceShapes(d.shape,p),_=t.util.sizeFromShape(b),y=n.makeOutput(h,s.dtype);if(0!==t.util.sizeFromShape(d.shape)){const e=n.dataIdMap.get(y.dataId).id;A(o,_,e)}if(m&&n.disposeData(l.dataId),i){const e=t.backend_util.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}};let x;const F={kernelName:t.Any,backendName:"wasm",setupFunc:function(e){x=e.wasm.cwrap(t.Any,null,["number, number, number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:u,keepDims:i}=r,{x:s}=a;let o=n.dataIdMap.get(s.dataId).id,d=s;const{transposed:l,axes:p,originalAxes:c,inputWasTransposed:m}=S(s,u,n);m&&(d=l,o=n.dataIdMap.get(l.dataId).id);const f=d.shape.length;t.backend_util.assertAxesAreInnerMostDims("any",p,f);const[h,b]=t.backend_util.computeOutAndReduceShapes(d.shape,p),_=t.util.sizeFromShape(b),y=n.makeOutput(h,s.dtype);if(0!==t.util.sizeFromShape(d.shape)){const e=n.dataIdMap.get(y.dataId).id;x(o,_,e)}if(m&&n.disposeData(l.dataId),i){const e=t.backend_util.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}};function N(e){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){const{backend:a,inputs:r,attrs:u}=e,{axis:i}=u,{x:o}=r,d=a.dataIdMap.get(o.dataId).id;let l=d,p=o;const{transposed:c,axes:m,inputWasTransposed:f}=S(o,i,a);if(f){const e=a.dataIdMap.get(c.dataId).id;e!==d&&(p=c,l=e)}const h=p.shape.slice(0,-1),b=a.makeOutput(h,"int32"),_=a.dataIdMap.get(b.dataId).id,y=t.util.sizeFromShape(b.shape),g=p.shape[m[0]];return n(l,s[p.dtype],y,g,_),f&&a.disposeData(c.dataId),b}}}const D=N(t.ArgMax),R=N(t.ArgMin),E=p(t.Asin),P=p(t.Asinh),C=p(t.Atan),W=h(t.Atan2),O=p(t.Atanh);let T;const z={kernelName:t.AvgPool,backendName:"wasm",setupFunc:function(e){T=e.wasm.cwrap(t.AvgPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,u=n.x,i=r.dataIdMap.get(u.dataId).id,{filterSize:s,strides:o,pad:d,dimRoundingMode:l}=a,p=t.backend_util.computePool2DInfo(u.shape,s,o,1,d,l),c=p.filterHeight,m=p.filterWidth,f=p.padInfo.top,h=p.padInfo.right,b=p.padInfo.bottom,_=p.padInfo.left,y=p.strideHeight,g=p.strideWidth,k=p.inChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(1!==p.dilationWidth||1!==p.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);const I=r.makeOutput(p.outShape,"float32"),w=r.dataIdMap.get(I.dataId).id;return T(i,u.shape[0],u.shape[1],u.shape[2],c,m,f,h,b,_,y,g,k,w),I}};let B;const H={kernelName:t.AvgPool3D,backendName:"wasm",setupFunc:function(e){B=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{filterSize:i,strides:s,pad:o,dimRoundingMode:d,dataFormat:l}=r,p=t.backend_util.computePool3DInfo(u.shape,i,s,1,o,d,l),c=a.makeOutput(p.outShape,u.dtype);return B(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),c}};let L;const G={kernelName:t.AvgPool3DGrad,backendName:"wasm",setupFunc:function(e){L=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:u,input:i}=n,{filterSize:s,strides:o,pad:d,dimRoundingMode:l}=r,p=t.backend_util.computePool3DInfo(i.shape,s,o,1,d,l),c=a.makeOutput(i.shape,i.dtype);return L(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left,p.filterDepth,p.filterHeight,p.filterWidth),c}};let U;const j={kernelName:t.AvgPoolGrad,backendName:"wasm",setupFunc:function(e){U=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:u,input:i}=n,{filterSize:s,strides:o,pad:d}=r,l=t.backend_util.computePool2DInfo(i.shape,s,o,1,d),p=a.makeOutput(i.shape,i.dtype);return U(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(p.dataId).id,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left,l.filterHeight,l.filterWidth),p}};function q(e){const{inputs:n,attrs:a}=e,{x:r}=n,{shape:u}=a,i=t.util.sizeFromShape(r.shape),s=t.util.inferFromImplicitShape(u,i);return t.util.assert(i===t.util.sizeFromShape(s),(()=>`new shape: ${s}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:s,dtype:r.dtype}}const V={kernelName:t.Reshape,backendName:"wasm",kernelFunc:q};let $;const K={kernelName:t.BatchMatMul,backendName:"wasm",setupFunc:function(e){$=e.wasm.cwrap(t.BatchMatMul,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{a:u,b:i}=n,{transposeA:s,transposeB:o}=r;if("float32"!==u.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const d=u.shape.length,l=i.shape.length,p=s?u.shape[d-2]:u.shape[d-1],c=o?i.shape[l-1]:i.shape[l-2],m=s?u.shape[d-1]:u.shape[d-2],f=o?i.shape[l-2]:i.shape[l-1],h=u.shape.slice(0,-2),b=i.shape.slice(0,-2),_=t.util.sizeFromShape(h),y=t.util.sizeFromShape(b),g=t.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,f]);t.util.assert(p===c,(()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${u.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`));const k=o?[y,f,c]:[y,c,f],I=q({inputs:{x:u},backend:a,attrs:{shape:s?[_,p,m]:[_,m,p]}}),w=q({inputs:{x:i},backend:a,attrs:{shape:k}}),M=a.dataIdMap.get(I.dataId).id,S=a.dataIdMap.get(w.dataId).id,A=s?I.shape[2]:I.shape[1],v=o?w.shape[1]:w.shape[2],x=Math.max(_,y),F=a.makeOutput([x,A,v],I.dtype),N=a.dataIdMap.get(F.dataId).id,D=new Uint8Array(new Int32Array(I.shape).buffer),R=new Uint8Array(new Int32Array(w.shape).buffer);return $(M,D,I.shape.length,S,R,w.shape.length,s,o,N),a.disposeData(I.dataId),a.disposeData(w.dataId),F.shape=g,F}};function X(e,n,a,r,u){const i=t.slice_util.isSliceContinous(r,n,a),s=t.util.sizeFromShape(a),o=t.util.computeStrides(r);if(i){const a=t.slice_util.computeFlatOffset(n,o);return"string"===u?e.slice(a,a+s):e.subarray(a,a+s)}const d="string"===u?t.backend_util.fromUint8ToStringArray(e):e,l=t.buffer(r,u,d),p=t.buffer(a,u);for(let e=0;e<p.size;++e){const t=p.indexToLoc(e),a=t.map(((e,t)=>e+n[t]));p.set(l.get(...a),...t)}return"string"===u?t.backend_util.fromStringArrayToUint8(p.values):p.values}t.backend_util.RowPartitionType;class Q{constructor(e,n,a,r,u,i){this.separator=t.util.encodeString(e),this.nGramWidths=n,this.leftPad=t.util.encodeString(a),this.rightPad=t.util.encodeString(r),this.padWidth=u,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,u){for(let i=0;i<r;++i){const s=this.getPadWidth(u),o=Math.max(0,s-i),d=Math.max(0,s-(r-(i+1))),l=u-(o+d),p=t+(o>0?0:i-s);let c=0;c+=o*this.leftPad.length;for(let t=0;t<l;++t)c+=e[p+t].length;c+=d*this.rightPad.length,c+=(o+d+l-1)*this.separator.length,n[a+i]=new Uint8Array(c);const m=n[a+i];let f=0;const h=e=>e.forEach((e=>m[f++]=e));for(let e=0;e<o;++e)h(this.leftPad),h(this.separator);for(let t=0;t<l-1;++t)h(e[p+t]),h(this.separator);if(l>0){h(e[p+l-1]);for(let e=0;e<d;++e)h(this.separator),h(this.rightPad)}else{for(let e=0;e<d-1;++e)h(this.rightPad),h(this.separator);h(this.rightPad)}}}compute(e,n){const a=e.length,r=n.length;if(r>0){let e=n[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let t=1;t<r;++t){let r=n[t]>=e;if(r=r&&n[t]<=a,!r)throw new Error(`Invalid split value ${n[t]}, must be in [${e}, ${a}]`);e=n[t]}if(e!==a)throw new Error(`Last split value must be data size. Expected ${a}, got ${e}`)}const u=r-1,i=t.util.getArrayFromDType("int32",r);if(0===a||0===r){const e=new Array(a);for(let e=0;e<=u;++e)i[e]=0;return[e,i]}i[0]=0;for(let e=1;e<=u;++e){const t=n[e]-n[e-1];let a=0;this.nGramWidths.forEach((e=>{a+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===a&&(a=1),i[e]=i[e-1]+a}const s=new Array(i[u]);for(let t=0;t<u;++t){const a=n[t];let r=i[t];if(this.nGramWidths.forEach((u=>{const i=n[t+1]-n[t],o=this.getNumNGrams(i,u);this.createNGrams(e,a,s,r,o,u),r+=o})),this.preserveShort&&r===i[t]){const u=n[t+1]-n[t];if(0===u)continue;const i=u+2*this.padWidth,o=1;this.createNGrams(e,a,s,r,o,i)}}return[s,i]}}function J(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let u=e.indexOf(r);for(;-1!==u;){const t=e.subarray(0,u);n&&0===t.length||a.push(t),u=(e=e.subarray(u+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let u=0;u<e.length+1;u++)if(u===e.length||-1!==t.indexOf(e[u])){const t=e.subarray(r,u);n&&0===t.length||a.push(t),r=u+1}}function Z(e){const{inputs:{x:n},attrs:{begin:a,size:r},backend:u}=e,[i,s]=t.slice_util.parseSliceParams(n,a,r),o=t.slice_util.isSliceContinous(n.shape,i,s),d=u.readSync(n.dataId),l=u.makeOutput(s,n.dtype),p=t.util.computeStrides(n.shape),c=u.dataIdMap.get(l.dataId);if(o){const e=t.slice_util.computeFlatOffset(i,p);return"string"===n.dtype?c.stringBytes=d.slice(e,e+t.util.sizeFromShape(s)):u.typedArrayFromHeap(l).set(d.subarray(e,e+t.util.sizeFromShape(s))),l}if("string"===n.dtype){const e=X(d,i,s,n.shape,n.dtype);return c.stringBytes=e,l}const m=u.typedArrayFromHeap(l),f=n.shape.length;if(2===f)!function(e,t,n,a,r){let u=0;const i=a[0],s=a[1],o=i+r[0];for(let a=i;a<o;a++){const i=a*t+s;n.set(e.subarray(i,i+r[1]),u),u+=r[1]}}(d,p[0],m,i,s);else if(3===f)!function(e,t,n,a,r,u){let i=0;const s=r[0],o=r[1],d=r[2],l=s+u[0],p=o+u[1];for(let r=s;r<l;r++)for(let s=o;s<p;s++){const o=r*t+s*n+d;a.set(e.subarray(o,o+u[2]),i),i+=u[2]}}(d,p[0],p[1],m,i,s);else if(4===f)!function(e,t,n,a,r,u,i){let s=0;const o=u[0],d=u[1],l=u[2],p=o+i[0],c=d+i[1],m=l+i[2],f=u[3];for(let u=o;u<p;u++)for(let o=d;o<c;o++)for(let d=l;d<m;d++){const l=u*t+o*n+d*a+f;r.set(e.subarray(l,l+i[3]),s),s+=i[3]}}(d,p[0],p[1],p[2],m,i,s);else{const e=X(d,i,s,n.shape,n.dtype);m.set(e)}return l}const Y={kernelName:t.Slice,backendName:"wasm",kernelFunc:Z},ee={kernelName:t.BatchToSpaceND,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{blockShape:i,crops:s}=r,o=i.reduce(((e,t)=>e*t)),d=t.backend_util.getReshaped(u.shape,i,o),l=t.backend_util.getPermuted(d.length,i.length),p=t.backend_util.getReshapedPermuted(u.shape,i,o),c=t.backend_util.getSliceBeginCoords(s,i.length),m=t.backend_util.getSliceSize(p,s,i.length),f=q({inputs:{x:u},backend:a,attrs:{shape:d}}),h=w({inputs:{x:f},backend:a,attrs:{perm:l}}),b=q({inputs:{x:h},backend:a,attrs:{shape:p}}),_=Z({inputs:{x:b},backend:a,attrs:{begin:c,size:m}});return a.disposeData(f.dataId),a.disposeData(h.dataId),a.disposeData(b.dataId),_}};let te;const ne={kernelName:t.Bincount,backendName:"wasm",setupFunc:function(e){te=e.wasm.cwrap(t.Bincount,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{x:r,weights:u}=n,{size:i}=a,o=0!==u.shape.reduce(((e,t)=>e*t),1),d=1===r.shape.length?[i]:[r.shape[0],i],l=t.makeOutput(d,u.dtype);function p(e){return t.dataIdMap.get(e.dataId).id}return te(p(r),i,o,p(u),s[u.dtype],p(l)),l}},ae=h(t.BitwiseAnd),re={kernelName:t.BroadcastArgs,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a}=e,{s0:r,s1:u}=n,i=a.typedArrayFromHeap(r),s=a.typedArrayFromHeap(u),o=t.backend_util.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return a.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function ue(e){const{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),u=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(u),r}const ie={kernelName:t.Cast,backendName:"wasm",kernelFunc:ue},se=p(t.Ceil);let oe;const de={kernelName:t.ClipByValue,backendName:"wasm",setupFunc:function(e){oe=e.wasm.cwrap(t.ClipByValue,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:u,clipValueMax:i}=a,s=n.dataIdMap.get(r.dataId).id,o=n.makeOutput(r.shape,r.dtype),d=n.dataIdMap.get(o.dataId).id;return oe(s,u,i,d),o}};function le(e){const{inputs:n,backend:a}=e,r=t.util.parseAxisParam(e.attrs.axis,n[0].shape)[0],u=n.map((e=>e.shape));t.backend_util.assertParamsConsistent(u,r);let i=t.backend_util.computeOutShape(n.map((e=>e.shape)),r);const s=n.filter((e=>t.util.sizeFromShape(e.shape)>0));if(1===s.length)return g({inputs:{x:s[0]},backend:a});const o=a.makeOutput(i,n[0].dtype);if(0===t.util.sizeFromShape(i))return o;if("string"===s[0].dtype){const e=s.map((e=>{const n=t.util.sizeFromShape(e.shape.slice(r));return q({inputs:{x:e},backend:a,attrs:{shape:[-1,n]}})})),u=e.map((e=>({vals:a.readSync(e.dataId),shape:e.shape})));i=t.backend_util.computeOutShape(e.map((e=>e.shape)),1);const d=1===e[0].shape[0],l=function(e,n,a,r){const u=t.util.getArrayFromDType(a,t.util.sizeFromShape(n));if(r&&"string"!==a){let n=0;e.forEach((e=>{const a=t.util.sizeFromShape(e.shape);u.set(e.vals,n),n+=a}))}else{let r=0;e.forEach((e=>{const i="string"===a?t.backend_util.fromUint8ToStringArray(e.vals):e.vals;let s=0;for(let t=0;t<e.shape[0];++t){const a=t*n[1]+r;for(let t=0;t<e.shape[1];++t)u[a+t]=i[s++]}r+=e.shape[1]}))}return u}(u,i,n[0].dtype,d),p=t.backend_util.computeOutShape(s.map((e=>e.shape)),r);return o.shape=p,a.dataIdMap.get(o.dataId).stringBytes=t.backend_util.fromStringArrayToUint8(l),e.forEach((e=>a.disposeData(e.dataId))),o}const d=t.util.sizeFromShape(s[0].shape.slice(0,r));let l=0;const p=s.map((e=>{const n=t.util.sizeFromShape(e.shape.slice(r));return l+=n,n})),c=s.map((e=>a.typedArrayFromHeap(e))),m=a.typedArrayFromHeap(o);for(let e=0;e<d;e++){let t=e*l;for(let n=0;n<c.length;n++){const a=p[n],r=e*a,u=c[n].subarray(r,r+a);m.set(u,t),t+=a}}return o}const pe={kernelName:t.Concat,backendName:"wasm",kernelFunc:le};let ce;const me={kernelName:t.Conv2D,backendName:"wasm",setupFunc:function(e){ce=e.wasm.cwrap(t.Conv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,{x:u,filter:i}=n,s=r.dataIdMap.get(u.dataId).id,o=r.dataIdMap.get(i.dataId).id,{strides:d,dilations:l,pad:p,dimRoundingMode:c,dataFormat:m}=a,f=t.backend_util.convertConv2DDataFormat(m),h=t.backend_util.computeConv2DInfo(u.shape,i.shape,d,l,p,c,!1,f),b=h.filterHeight,_=h.filterWidth,y=h.padInfo.top,g=h.padInfo.right,k=h.padInfo.bottom,I=h.padInfo.left,w=h.dilationHeight,M=h.dilationWidth,S=h.strideHeight,A=h.strideWidth,v=h.inChannels,x=h.outChannels,F="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);const N=r.makeOutput(h.outShape,"float32"),D=r.dataIdMap.get(N.dataId).id;return ce(s,u.shape[0],u.shape[1],u.shape[2],o,b,_,y,g,k,I,F,w,M,S,A,v,x,D),N}};let fe;const he={kernelName:t.Conv2DBackpropInput,backendName:"wasm",setupFunc:function(e){fe=e.wasm.cwrap(t.Conv2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{dy:u,filter:i}=a,{strides:s,pad:o,dataFormat:d,dimRoundingMode:l,inputShape:p}=r,c=t.backend_util.convertConv2DDataFormat(d),m=t.backend_util.computeConv2DInfo(p,i.shape,s,1,o,l,!1,c),{batchSize:f,filterHeight:h,filterWidth:b,inChannels:_,inHeight:y,inWidth:g,outChannels:k,outHeight:I,outWidth:w,strideHeight:M,strideWidth:S}=m,A=h-1-m.padInfo.top,v=b-1-m.padInfo.left,x="channelsLast"===m.dataFormat,F=t.util.computeStrides(m.inShape),N=t.util.computeStrides(u.shape),[D,R,E]=t.util.computeStrides(i.shape),P=F[0],C=x?F[1]:F[2],W=x?F[2]:1,O=x?1:F[1],T=N[0],z=x?N[1]:N[2],B=x?N[2]:1,H=x?1:N[1],L=n.makeOutput(m.inShape,"float32"),G=n.dataIdMap.get(L.dataId).id,U=n.dataIdMap.get(u.dataId).id,j=n.dataIdMap.get(i.dataId).id;return fe(U,j,f,h,b,y,g,_,I,w,k,M,S,A,v,D,R,E,P,C,W,O,T,z,B,H,G),L}};let be;const _e={kernelName:t.Conv3D,backendName:"wasm",setupFunc:function(e){be=e.wasm.cwrap(t.Conv3D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u,filter:i}=n,{strides:s,pad:o,dilations:d}=r;if("float32"!==u.dtype)throw new Error(`Tensor x must have dtype float32, got ${u.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);const l=t.backend_util.computeConv3DInfo(u.shape,i.shape,s,d,o),p=a.makeOutput(l.outShape,u.dtype);return be(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(p.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),p}};let ye;const ge={kernelName:t.Conv3DBackpropFilterV2,backendName:"wasm",setupFunc:function(e){ye=e.wasm.cwrap(t.Conv3DBackpropFilterV2,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u,dy:i}=n,{strides:s,pad:o,filterShape:d}=r;if("float32"!==u.dtype)throw new Error(`Tensor dy must have dtype float32, got ${u.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);const l=t.backend_util.computeConv3DInfo(u.shape,d,s,1,o),p=a.makeOutput(l.filterShape,i.dtype);return ye(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(p.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),p}};let ke;const Ie={kernelName:t.Conv3DBackpropInputV2,backendName:"wasm",setupFunc:function(e){ke=e.wasm.cwrap(t.Conv3DBackpropInputV2,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:u,filter:i}=n,{pad:s,strides:o,inputShape:d}=r;if("float32"!==u.dtype)throw new Error(`Tensor dy must have dtype float32, got ${u.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);const l=t.backend_util.computeConv3DInfo(d,i.shape,o,1,s),p=a.makeOutput(l.inShape,u.dtype);return ke(a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(p.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),p}},we=p(t.Cos),Me=p(t.Cosh);var Se;let Ae;!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(Se||(Se={}));const ve={kernelName:t.CropAndResize,backendName:"wasm",setupFunc:function(e){Ae=e.wasm.cwrap(t.CropAndResize,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:u,cropSize:i}=a,{image:s,boxes:o,boxInd:d}=n,l=o.shape[0],[p,c]=i,m=[l,p,c,s.shape[3]];let f,h=t.dataIdMap.get(s.dataId);"float32"!==s.dtype&&(f=ue({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(f.dataId));const b=h.id,_=t.dataIdMap.get(o.dataId).id,y=t.dataIdMap.get(d.dataId).id,g=t.makeOutput(m,"float32"),k=t.dataIdMap.get(g.dataId).id,I=new Uint8Array(new Int32Array(s.shape).buffer);return Ae(b,_,y,l,I,p,c,Se[r],u,k),null!=f&&t.disposeData(f.dataId),g}};let xe;const Fe={kernelName:t.Cumprod,backendName:"wasm",setupFunc:function(e){xe=e.wasm.cwrap(t.Cumprod,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{axis:i,exclusive:o,reverse:d}=r,l=u.shape.length;t.util.assert("float32"===u.dtype||"int32"===u.dtype,(()=>`cumprod does not support ${u.dtype} tensors in the WASM backend`));const p=t.backend_util.getAxesPermutation([i],l);let c=u;null!==p&&(c=w({inputs:{x:u},attrs:{perm:p},backend:a}));const m=t.backend_util.getInnerMostAxes(1,l)[0];t.backend_util.assertAxesAreInnerMostDims("cumprod",[m],l);const f=a.makeOutput(c.shape,c.dtype),h=c.shape[m],b=a.dataIdMap.get(c.dataId).id,_=a.dataIdMap.get(f.dataId).id;xe(b,o?1:0,d?1:0,h,_,s[u.dtype]);let y=f;return null!==p&&(y=w({inputs:{x:f},attrs:{perm:t.backend_util.getUndoAxesPermutation(p)},backend:a}),a.disposeData(c.dataId),a.disposeData(f.dataId)),y}};let Ne;const De={kernelName:t.Cumsum,backendName:"wasm",setupFunc:function(e){Ne=e.wasm.cwrap(t.Cumsum,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{axis:i,exclusive:o,reverse:d}=r,l=u.shape.length;t.util.assert("float32"===u.dtype||"int32"===u.dtype,(()=>`cumsum does not support ${u.dtype} tensors in the WASM backend`));const p=t.backend_util.getAxesPermutation([i],l);let c=u;null!==p&&(c=w({inputs:{x:u},attrs:{perm:p},backend:a}));const m=t.backend_util.getInnerMostAxes(1,l)[0];t.backend_util.assertAxesAreInnerMostDims("cumsum",[m],l);const f=a.makeOutput(c.shape,c.dtype),h=c.shape[m],b=a.dataIdMap.get(c.dataId).id,_=a.dataIdMap.get(f.dataId).id;Ne(b,o?1:0,d?1:0,h,_,s[u.dtype]);let y=f;return null!==p&&(y=w({inputs:{x:f},attrs:{perm:t.backend_util.getUndoAxesPermutation(p)},backend:a}),a.disposeData(c.dataId),a.disposeData(f.dataId)),y}};let Re;const Ee={kernelName:t.DenseBincount,backendName:"wasm",setupFunc:function(e){Re=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{x:r,weights:u}=n,{size:i,binaryOutput:o}=a,d=0!==u.shape.reduce(((e,t)=>e*t),1),l=1===r.shape.length?[i]:[r.shape[0],i],p=t.makeOutput(l,u.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return Re(c(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,d,c(u),s[u.dtype],o,c(p)),p}};let Pe;const Ce={kernelName:t.DepthToSpace,backendName:"wasm",setupFunc:function(e){Pe=e.wasm.cwrap(t.DepthToSpace,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{x:u}=a,{blockSize:i,dataFormat:s}=r,o=u.shape[0],d=("NHWC"===s?u.shape[1]:u.shape[2])*i,l=("NHWC"===s?u.shape[2]:u.shape[3])*i,p=("NHWC"===s?u.shape[3]:u.shape[1])/(i*i),c="NHWC"===s?[o,d,l,p]:[o,p,d,l],m=n.makeOutput(c,"float32"),f=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),b=new Uint8Array(new Int32Array(c).buffer),_=new Uint8Array(new Int32Array(t.util.computeStrides(c)).buffer),y=n.dataIdMap.get(m.dataId).id;return Pe(f,i,"NHWC"===s?1:0,h,u.shape.length-1,b,_,c.length,y),m}};let We;const Oe={kernelName:t.DepthwiseConv2dNative,backendName:"wasm",setupFunc:function(e){We=e.wasm.cwrap(t.DepthwiseConv2dNative,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,{x:u,filter:i}=n,s=r.dataIdMap.get(u.dataId).id,o=r.dataIdMap.get(i.dataId).id,{strides:d,dilations:l,pad:p,dimRoundingMode:c}=a,m=null==l?[1,1]:l,f=t.backend_util.computeConv2DInfo(u.shape,i.shape,d,m,p,c,!0),h=f.filterHeight,b=f.filterWidth,_=f.padInfo.top,y=f.padInfo.right,g=f.padInfo.bottom,k=f.padInfo.left,I=f.dilationHeight,w=f.dilationWidth,M=f.strideHeight,S=f.strideWidth,A=f.inChannels,v=f.outChannels,x="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const F=r.makeOutput(f.outShape,"float32"),N=r.dataIdMap.get(F.dataId).id;return We(s,u.shape[0],u.shape[1],u.shape[2],o,h,b,_,y,g,k,x,I,w,M,S,A,v,N),F}};let Te;const ze={kernelName:t.Diag,backendName:"wasm",setupFunc:function(e){Te=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r}=n,u=t.util.sizeFromShape(r.shape),i=a.makeOutput([...r.shape,...r.shape],r.dtype);return Te(a.dataIdMap.get(r.dataId).id,s[r.dtype],u,a.dataIdMap.get(i.dataId).id),i}};let Be;const He={kernelName:t.Dilation2D,backendName:"wasm",setupFunc:function(e){Be=e.wasm.cwrap(t.Dilation2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u,filter:i}=n,{strides:o,pad:d,dilations:l}=r;if(u.dtype!==i.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${u.dtype} and ${i.dtype}`);const p=t.backend_util.computeDilation2DInfo(u.shape,i.shape,o,d,"NHWC",l),c=a.makeOutput(p.outShape,u.dtype);return Be(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(c.dataId).id,s[u.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),c}};let Le;const Ge={kernelName:t.Dilation2DBackpropFilter,backendName:"wasm",setupFunc:function(e){Le=e.wasm.cwrap(t.Dilation2DBackpropFilter,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u,filter:i,dy:o}=n,{strides:d,pad:l,dilations:p}=r;if(u.dtype!==i.dtype||u.dtype!==o.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${u.dtype}, ${i.dtype}, and ${o.dtype}`);const c=t.backend_util.computeDilation2DInfo(u.shape,i.shape,d,l,"NHWC",p),m=a.makeOutput(i.shape,i.dtype);return Le(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(o.dataId).id,a.dataIdMap.get(m.dataId).id,s[u.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),m}};let Ue;const je={kernelName:t.Dilation2DBackpropInput,backendName:"wasm",setupFunc:function(e){Ue=e.wasm.cwrap(t.Dilation2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u,filter:i,dy:o}=n,{strides:d,pad:l,dilations:p}=r;if(u.dtype!==i.dtype||u.dtype!==o.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${u.dtype}, ${i.dtype}, and ${o.dtype}`);const c=t.backend_util.computeDilation2DInfo(u.shape,i.shape,d,l,"NHWC",p),m=a.makeOutput(u.shape,u.dtype);return Ue(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(o.dataId).id,a.dataIdMap.get(m.dataId).id,s[u.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),m}},qe=p(t.Elu);let Ve;const $e={kernelName:t.EluGrad,backendName:"wasm",setupFunc:function(e){Ve=e.wasm.cwrap(t.EluGrad,null,["number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t,u=n.makeOutput(r.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return Ve(i(r),i(a),i(u)),u}},Ke=h(t.Equal,0,"bool"),Xe=p(t.Erf),Qe=p(t.Exp,"float32");function Je(e){const{inputs:n,attrs:a,backend:r}=e,{input:u}=n,{dim:i}=a,s=u.shape.length,o=u.shape.slice();let d=i;return i<0&&(t.util.assert(-(s+1)<=i,(()=>`Axis must be in the interval [${-(s+1)}, ${s}]`)),d=s+i+1),o.splice(d,0,1),q({inputs:{x:u},backend:r,attrs:{shape:o}})}const Ze={kernelName:t.ExpandDims,backendName:"wasm",kernelFunc:Je},Ye=p(t.Expm1,"float32");function et(e){const{attrs:{shape:n,value:a},backend:r}=e;let{attrs:{dtype:u}}=e;u=u||t.util.inferDtype(a);const i=r.makeOutput(n,u);return r.typedArrayFromHeap(i).fill(a),i}const tt={kernelName:t.Fill,backendName:"wasm",kernelFunc:et};let nt;const at={kernelName:t.FlipLeftRight,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[s,o,d,l]=a.shape;return nt(u,s,o,d,l,i),r},setupFunc:function(e){nt=e.wasm.cwrap(t.FlipLeftRight,null,["number","number","number","number","number","number"])}},rt=p(t.Floor),ut=h(t.FloorDiv);let it;const st={kernelName:t.FusedBatchNorm,backendName:"wasm",setupFunc:function(e){it=e.wasm.cwrap(t.FusedBatchNorm,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{varianceEpsilon:u}=r,{x:i,mean:s,variance:o,offset:d,scale:l}=a,p=n.dataIdMap.get(i.dataId).id,c=n.dataIdMap.get(s.dataId).id,m=n.dataIdMap.get(o.dataId).id,f=null!=d?n.dataIdMap.get(d.dataId).id:0,h=null!=l?n.dataIdMap.get(l.dataId).id:0,b=n.makeOutput(i.shape,i.dtype);if(0===t.util.sizeFromShape(i.shape))return b;const _=n.dataIdMap.get(b.dataId).id;return it(p,c,m,f,h,u,_),b}};let ot;const dt={kernelName:t.FusedConv2D,backendName:"wasm",setupFunc:function(e){ot=e.wasm.cwrap(t.FusedConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,{x:u,filter:i,bias:s,preluActivationWeights:d}=n,{strides:l,pad:p,dilations:c,dataFormat:m,dimRoundingMode:f,activation:h,leakyreluAlpha:b}=a,_=t.backend_util.computeConv2DInfo(u.shape,i.shape,l,c,p,f),y=o[h];if(null==y)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);const g=r.dataIdMap.get(u.dataId).id,k=r.dataIdMap.get(i.dataId).id,I=_.outChannels;let w=0;if(null!=s){const e=r.dataIdMap.get(s.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==I)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);w=e.id}const M=_.filterHeight,S=_.filterWidth,A=_.padInfo.top,v=_.padInfo.right,x=_.padInfo.bottom,F=_.padInfo.left,N=_.dilationHeight,D=_.dilationWidth,R=_.strideHeight,E=_.strideWidth,P=_.inChannels,C="SAME"===_.padInfo.type?1:0,W=_.batchSize,O=_.inHeight,T=_.inWidth;if("NHWC"!==m)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);const z=r.makeOutput(_.outShape,"float32"),B=r.dataIdMap.get(z.dataId).id,H=null==d?0:r.dataIdMap.get(d.dataId).id;return ot(g,W,O,T,k,M,S,w,A,v,x,F,C,N,D,R,E,P,I,y,H,b||0,B),z}};let lt;const pt={kernelName:t.FusedDepthwiseConv2D,backendName:"wasm",setupFunc:function(e){lt=e.wasm.cwrap(t.FusedDepthwiseConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,{x:u,filter:i,bias:s,preluActivationWeights:d}=n,{strides:l,pad:p,dilations:c,dataFormat:m,dimRoundingMode:f,activation:h,leakyreluAlpha:b}=a,_=t.backend_util.computeConv2DInfo(u.shape,i.shape,l,c,p,f,!0),y=o[h];if(null==y)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const g=r.dataIdMap.get(u.dataId).id,k=r.dataIdMap.get(i.dataId).id,I=_.outChannels;let w=0;if(null!=s){const e=r.dataIdMap.get(s.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==I)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);w=e.id}const M=_.filterHeight,S=_.filterWidth,A=_.padInfo.top,v=_.padInfo.right,x=_.padInfo.bottom,F=_.padInfo.left,N=_.dilationHeight,D=_.dilationWidth,R=_.strideHeight,E=_.strideWidth,P=_.inChannels,C="SAME"===_.padInfo.type?1:0,W=_.batchSize,O=_.inHeight,T=_.inWidth;if("NHWC"!==m)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);const z=r.makeOutput(_.outShape,"float32"),B=r.dataIdMap.get(z.dataId).id,H=null==d?0:r.dataIdMap.get(d.dataId).id;return lt(g,W,O,T,k,M,S,w,A,v,x,F,C,N,D,R,E,P,I,y,H,b||0,B),z}};let ct;const mt={kernelName:t.GatherNd,backendName:"wasm",setupFunc:function(e){ct=e.wasm.cwrap(t.GatherNd,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){const{backend:n,inputs:a}=e,{params:r,indices:u}=a,[i,o,d,l]=t.gather_util.prepareAndValidate(r,u),p=n.makeOutput(i,r.dtype);if(0===o)return p;const c=u.shape,m=c[c.length-1],f=n.dataIdMap.get(r.dataId).id,h=n.dataIdMap.get(u.dataId).id,b=new Uint8Array(new Int32Array(l).buffer),_=n.dataIdMap.get(p.dataId).id;return ct(f,s[r.dtype],h,o,m,d,b,_),p}};let ft;const ht={kernelName:t.GatherV2,backendName:"wasm",setupFunc:function(e){ft=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{x:u,indices:i}=a,{axis:o,batchDims:d}=r,l=t.util.parseAxisParam(o,u.shape)[0],p=n.readSync(i.dataId),c=u.shape[l];for(let e=0;e<p.length;++e){const n=p[e];t.util.assert(n<=c-1&&n>=0,(()=>`GatherV2: the index value ${n} is not in [0, ${c-1}]`))}const m=t.backend_util.segment_util.collectGatherOpShapeInfo(u,i,l,d),f=q({inputs:{x:u},attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]},backend:n}),h=t.util.sizeFromShape(i.shape),b=q({inputs:{x:i},attrs:{shape:[m.batchSize,h/m.batchSize]},backend:n}),_=[m.batchSize,m.outerSize,h/m.batchSize,m.sliceSize],y=n.makeOutput(_,u.dtype);if(0===t.util.sizeFromShape(u.shape))return y;const g=f.shape.length-1,k=n.dataIdMap.get(f.dataId).id,I=n.dataIdMap.get(b.dataId).id,w=n.dataIdMap.get(y.dataId).id,M=new Uint8Array(new Int32Array(t.util.computeStrides(f.shape)).buffer),S=new Uint8Array(new Int32Array(t.util.computeStrides(_)).buffer);return ft(k,s[u.dtype],M,g,I,m.batchSize,S,w),n.disposeData(f.dataId),n.disposeData(b.dataId),y.shape=m.outputShape,y}},bt=h(t.Greater,0,"bool"),_t=h(t.GreaterEqual,0,"bool"),yt=p(t.IsFinite,"bool"),gt=p(t.IsInf,"bool"),kt=p(t.IsNan,"bool");let It;const wt={kernelName:t.LeakyRelu,backendName:"wasm",setupFunc:function(e){It=e.wasm.cwrap(t.LeakyRelu,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:{x:n},attrs:{alpha:a},backend:r}=e,u=r.dataIdMap.get(n.dataId).id,i=r.makeOutput(n.shape,"float32");if(0!==t.util.sizeFromShape(n.shape)){const e=r.dataIdMap.get(i.dataId).id;It(u,s[n.dtype],a,e)}return i}},Mt=h(t.Less,0,"bool"),St=h(t.LessEqual,0,"bool");let At;const vt={kernelName:t.LinSpace,backendName:"wasm",setupFunc:function(e){At=e.wasm.cwrap(t.LinSpace,null,["number","number","number","number"])},kernelFunc:function(e){const{attrs:t,backend:n}=e,{start:a,stop:r,num:u}=t,i=Math.floor(u),s=n.makeOutput([i],"float32");return At(n.dataIdMap.get(s.dataId).id,a,r,i),s}},xt=p(t.Log),Ft=p(t.Log1p),Nt=h(t.LogicalAnd,0,"bool"),Dt=p(t.LogicalNot),Rt=h(t.LogicalOr,0,"bool"),Et=h(t.LogicalXor,0,"bool");let Pt;const Ct={kernelName:t.LRN,backendName:"wasm",setupFunc:function(e){Pt=e.wasm.cwrap(t.LRN,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:u,bias:i,alpha:s,beta:o}=a;if("float32"!==r.dtype)throw new Error("LRN error: x must have dtype float32");const d=n.makeOutput(r.shape,r.dtype);return Pt(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,r.shape[3],u,i,s,o),d}};let Wt;const Ot={kernelName:t.LRNGrad,backendName:"wasm",setupFunc:function(e){Wt=e.wasm.cwrap(t.LRNGrad,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:u,dy:i}=t,{depthRadius:s,bias:o,alpha:d,beta:l}=a;if("float32"!==r.dtype||"float32"!==u.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");const p=n.makeOutput(r.shape,r.dtype);return Wt(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(p.dataId).id,i.shape[3],s,o,d,l),p}};let Tt;const zt={kernelName:t.Max,backendName:"wasm",setupFunc:function(e){Tt=e.wasm.cwrap(t.Max,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{reductionIndices:u,keepDims:i}=r,{x:o}=a;let d=n.dataIdMap.get(o.dataId).id,l=o;const{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=S(o,u,n);f&&(l=p,d=n.dataIdMap.get(p.dataId).id);const h=l.shape.length;t.backend_util.assertAxesAreInnerMostDims("max",c,h);const[b,_]=t.backend_util.computeOutAndReduceShapes(l.shape,c),y=t.util.sizeFromShape(_),g=n.makeOutput(b,o.dtype);if(0!==t.util.sizeFromShape(l.shape)){const e=n.dataIdMap.get(g.dataId).id;Tt(d,s[o.dtype],y,e)}if(f&&n.disposeData(p.dataId),i){const e=t.backend_util.expandShapeToKeepDim(g.shape,m);g.shape=e}return g}},Bt=h(t.Maximum);let Ht;const Lt={kernelName:t.MaxPool,backendName:"wasm",setupFunc:function(e){Ht=e.wasm.cwrap(t.MaxPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,u=n.x,i=r.dataIdMap.get(u.dataId).id;t.util.assert("float32"===u.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${u.dtype}.`));const{filterSize:s,strides:o,pad:d,dimRoundingMode:l}=a,p=t.backend_util.computePool2DInfo(u.shape,s,o,1,d,l),c=p.filterHeight,m=p.filterWidth,f=p.padInfo.top,h=p.padInfo.right,b=p.padInfo.bottom,_=p.padInfo.left,y=p.dilationHeight,g=p.dilationWidth,k=p.strideHeight,I=p.strideWidth,w=p.inChannels,M=p.outChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);const S=r.makeOutput(p.outShape,"float32"),A=r.dataIdMap.get(S.dataId).id;return Ht(i,u.shape[0],u.shape[1],u.shape[2],c,m,f,h,b,_,y,g,k,I,w,M,A),S}};let Gt;const Ut={kernelName:t.MaxPool3D,backendName:"wasm",setupFunc:function(e){Gt=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{filterSize:i,strides:s,pad:o,dimRoundingMode:d,dataFormat:l}=r,p=t.backend_util.computePool3DInfo(u.shape,i,s,1,o,d,l),c=a.makeOutput(p.outShape,u.dtype);return Gt(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),c}};let jt;const qt={kernelName:t.MaxPool3DGrad,backendName:"wasm",setupFunc:function(e){jt=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:u,input:i}=n,{filterSize:s,strides:o,pad:d,dimRoundingMode:l}=r,p=t.backend_util.computePool3DInfo(i.shape,s,o,1,d,l),c=a.makeOutput(i.shape,i.dtype);return jt(a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),c}};let Vt;const $t={kernelName:t.MaxPoolGrad,backendName:"wasm",setupFunc:function(e){Vt=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:u,input:i}=n,{filterSize:s,strides:o,pad:d,dimRoundingMode:l}=r,p=t.backend_util.computePool2DInfo(i.shape,s,o,1,d,l),c=a.makeOutput(i.shape,i.dtype);return Vt(a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(c.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),c}};let Kt;const Xt={kernelName:t.MaxPoolWithArgmax,backendName:"wasm",setupFunc:function(e){Kt=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{filterSize:i,strides:o,pad:d,includeBatchInIndex:l}=r;t.util.assert(4===u.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`));const p=[1,1];t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(o,p),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`));const c=t.backend_util.computePool2DInfo(u.shape,i,o,[1,1],d),m=a.makeOutput(c.outShape,u.dtype),f=a.makeOutput(c.outShape,"int32");return Kt(a.dataIdMap.get(u.dataId).id,a.dataIdMap.get(m.dataId).id,a.dataIdMap.get(f.dataId).id,s[u.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[m,f]}};let Qt;const Jt={kernelName:t.Mean,backendName:"wasm",setupFunc:function(e){Qt=e.wasm.cwrap(t.Mean,null,["number, number, number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:u,keepDims:i}=r,{x:s}=a,o=n.dataIdMap.get(s.dataId).id;let d=o,l=s;const{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=S(s,u,n);let h=c;if(f){const e=n.dataIdMap.get(p.dataId).id;e!==o&&(l=p,d=e,h=t.backend_util.getInnerMostAxes(h.length,l.shape.length))}t.backend_util.assertAxesAreInnerMostDims("mean",h,l.shape.length);const[b,_]=t.backend_util.computeOutAndReduceShapes(l.shape,h),y=t.util.sizeFromShape(_);let g=l;"float32"!==l.dtype&&(g=ue({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),d=n.dataIdMap.get(g.dataId).id);const k=n.makeOutput(b,"float32");if(0!==t.util.sizeFromShape(l.shape)){const e=n.dataIdMap.get(k.dataId).id;Qt(d,y,e)}if(f&&n.disposeData(p.dataId),i){const e=t.backend_util.expandShapeToKeepDim(k.shape,m);k.shape=e}return"float32"!==l.dtype&&n.disposeData(g.dataId),k}};let Zt;const Yt={kernelName:t.Min,backendName:"wasm",setupFunc:function(e){Zt=e.wasm.cwrap(t.Min,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:u,keepDims:i}=r,{x:o}=a,d=n.dataIdMap.get(o.dataId).id;let l=d,p=o;const{transposed:c,axes:m,originalAxes:f,inputWasTransposed:h}=S(o,u,n);if(h){const e=n.dataIdMap.get(c.dataId).id;e!==d&&(p=c,l=e)}const b=p.shape.length;t.backend_util.assertAxesAreInnerMostDims("min",m,b);const[_,y]=t.backend_util.computeOutAndReduceShapes(p.shape,m),g=t.util.sizeFromShape(y),k=n.makeOutput(_,p.dtype);if(0!==t.util.sizeFromShape(p.shape)){const e=n.dataIdMap.get(k.dataId).id;Zt(l,s[o.dtype],g,e)}if(h&&n.disposeData(c.dataId),i){const e=t.backend_util.expandShapeToKeepDim(k.shape,f);k.shape=e}return k}},en=h(t.Minimum);var tn;let nn;!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(tn||(tn={}));const an={kernelName:t.MirrorPad,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,u=a.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(u,t.dtype),d=n.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),p=a.map((e=>e[0])),c=a.map((e=>e[1])),m=new Uint8Array(new Int32Array(p).buffer),f=new Uint8Array(new Int32Array(c).buffer);return nn(i,l,t.shape.length,s[t.dtype],m,f,tn[r],d),o},setupFunc:function(e){nn=e.wasm.cwrap(t.MirrorPad,null,["number","array","number","number","array","array","number","number"])}};let rn;function un(e){const{backend:n,inputs:{logits:a},attrs:{dim:r}}=e,u=n.dataIdMap.get(a.dataId).id,i=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(i.dataId).id,o=a.shape[r],d=t.util.sizeFromShape(a.shape)/o;return 0===t.util.sizeFromShape(i.shape)||rn(u,s,o,d),i}const sn={kernelName:t.Softmax,backendName:"wasm",setupFunc:function(e){rn=e.wasm.cwrap(t.Softmax,null,["number","number","number","number"])},kernelFunc:un};let on;const dn={kernelName:t.Multinomial,backendName:"wasm",setupFunc:function(e){on=e.wasm.cwrap(t.Multinomial,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:u,seed:i,normalized:s}=a;if("float32"!==r.dtype)throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);const o=s?r:un({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[d,l]=o.shape,p=n.makeOutput([d,u],"int32");return on(n.dataIdMap.get(o.dataId).id,d,l,u,i,n.dataIdMap.get(p.dataId).id),s||n.disposeData(o.dataId),p}},ln=h(t.Mod),pn=h(t.Multiply),cn=p(t.Neg);function mn(e,t){const n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],u=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:u,pValidOutputs:i}}let fn;const hn={kernelName:t.NonMaxSuppressionV3,backendName:"wasm",setupFunc:function(e){fn=e.wasm.cwrap(t.NonMaxSuppressionV3,"number",["number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:u,scoreThreshold:i}=a,{boxes:s,scores:o}=n,d=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(o.dataId).id,p=fn(d,l,u,r,i),{pSelectedIndices:c,selectedSize:m,pSelectedScores:f,pValidOutputs:h}=mn(t,p);return t.wasm._free(f),t.wasm._free(h),t.makeOutput([m],"int32",c)}};let bn;const _n={kernelName:t.NonMaxSuppressionV4,backendName:"wasm",setupFunc:function(e){bn=e.wasm.cwrap(t.NonMaxSuppressionV4,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:u,scoreThreshold:i,padToMaxOutputSize:s}=a,{boxes:o,scores:d}=n,l=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(d.dataId).id,c=bn(l,p,u,r,i,s),{pSelectedIndices:m,selectedSize:f,pSelectedScores:h,pValidOutputs:b}=mn(t,c);return t.wasm._free(h),[t.makeOutput([f],"int32",m),t.makeOutput([],"int32",b)]}};let yn;const gn={kernelName:t.NonMaxSuppressionV5,backendName:"wasm",setupFunc:function(e){yn=e.wasm.cwrap(t.NonMaxSuppressionV5,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:u,scoreThreshold:i,softNmsSigma:s}=a,{boxes:o,scores:d}=n,l=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(d.dataId).id,c=yn(l,p,u,r,i,s),{pSelectedIndices:m,selectedSize:f,pSelectedScores:h,pValidOutputs:b}=mn(t,c);return t.wasm._free(b),[t.makeOutput([f],"int32",m),t.makeOutput([f],"float32",h)]}},kn=h(t.NotEqual,0,"bool");let In;const wn={kernelName:t.OneHot,backendName:"wasm",setupFunc:function(e){In=e.wasm.cwrap(t.OneHot,null,["number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:u,depth:i,onValue:s,offValue:o}=a,d=n.makeOutput([...r.shape,i],u),l=n.dataIdMap.get(d.dataId).id,p=n.dataIdMap.get(r.dataId).id;return In(p,i,s,o,l),d}},Mn={kernelName:t.OnesLike,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}},Sn={kernelName:t.Pack,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{axis:u}=r;if(1===n.length)return Je({inputs:{input:n[0]},backend:a,attrs:{dim:u}});const i=n[0].shape,s=n[0].dtype;n.forEach((e=>{t.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],d=le({inputs:n.map((e=>{const t=Je({inputs:{input:e},backend:a,attrs:{dim:u}});return o.push(t),t})),backend:a,attrs:{axis:u}});return o.forEach((e=>a.disposeData(e.dataId))),d}};let An;const vn={kernelName:t.PadV2,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:n},backend:a,attrs:{paddings:r,constantValue:u}}=e,i=r.map(((e,t)=>e[0]+n.shape[t]+e[1]));if(0===t.util.sizeFromShape(n.shape))return et({backend:a,attrs:{shape:i,value:u,dtype:n.dtype}});const o=a.dataIdMap.get(n.dataId).id,d=a.makeOutput(i,n.dtype),l=a.dataIdMap.get(d.dataId).id,p=new Uint8Array(new Int32Array(n.shape).buffer),c=r.map((e=>e[0])),m=r.map((e=>e[1])),f=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(m).buffer);return An(o,p,n.shape.length,s[n.dtype],f,h,u,l),d},setupFunc:function(e){An=e.wasm.cwrap(t.PadV2,null,["number","array","number","number","array","array","number","number"])}},xn=h(t.Pow);let Fn;const Nn={kernelName:t.Prelu,backendName:"wasm",setupFunc:function(e){Fn=e.wasm.cwrap(t.Prelu,null,["number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,u=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id;let s=u;const o=a;let d=o;"float32"!==o.dtype&&(d=ue({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),s=n.dataIdMap.get(d.dataId).id);const l=n.makeOutput(a.shape,"float32"),p=n.dataIdMap.get(l.dataId).id;return Fn(s,i,p),"float32"!==o.dtype&&n.disposeData(d.dataId),l}};let Dn;const Rn={kernelName:t.Prod,backendName:"wasm",setupFunc:function(e){Dn=e.wasm.cwrap(t.Prod,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:u,keepDims:i}=r,{x:o}=a,d=n.dataIdMap.get(o.dataId).id;let l=d,p=o;const{transposed:c,axes:m,originalAxes:f,inputWasTransposed:h}=S(o,u,n);let b=m;if(h){const e=n.dataIdMap.get(c.dataId).id;e!==d&&(p=c,l=e,b=t.backend_util.getInnerMostAxes(b.length,p.shape.length))}t.backend_util.assertAxesAreInnerMostDims("prod",b,p.shape.length);const[_,y]=t.backend_util.computeOutAndReduceShapes(p.shape,b),g=t.util.sizeFromShape(y),k=n.makeOutput(_,p.dtype);if(0!==t.util.sizeFromShape(p.shape)){const e=n.dataIdMap.get(k.dataId).id;Dn(l,g,s[k.dtype],e)}if(h&&n.disposeData(c.dataId),i){const e=t.backend_util.expandShapeToKeepDim(k.shape,f);k.shape=e}return k}},En={kernelName:t.Range,backendName:"wasm",kernelFunc:e=>{const{backend:n,attrs:a}=e,{start:r,stop:u,step:i,dtype:s}=a,o=function(e,n,a,r){if(e===n||e<n&&a<0||n<e&&a>1)return t.util.makeZerosTypedArray(0,r);const u=Math.abs(Math.ceil((n-e)/a)),i=t.util.makeZerosTypedArray(u,r);n<e&&1===a&&(a=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+a;return i}(r,u,i,s),d=n.makeOutput([o.length],s);return n.typedArrayFromHeap(d).set(o),d}},Pn=h(t.RealDiv),Cn=p(t.Reciprocal),Wn=p(t.Relu),On=p(t.Relu6);let Tn;const zn={kernelName:t.ResizeBilinear,backendName:"wasm",setupFunc:function(e){Tn=e.wasm.cwrap(t.ResizeBilinear,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{images:u}=a,{alignCorners:i,halfPixelCenters:s,size:o}=r,[d,l]=o,[p,c,m,f]=u.shape,h=[p,d,l,f];let b,_=n.dataIdMap.get(u.dataId);"float32"!==_.dtype&&(b=ue({backend:n,inputs:{x:u},attrs:{dtype:"float32"}}),_=n.dataIdMap.get(b.dataId));const y=_.id,g=n.makeOutput(h,"float32");if(0===t.util.sizeFromShape(u.shape))return g;const k=n.dataIdMap.get(g.dataId).id;return Tn(y,p,c,m,f,d,l,i?1:0,s?1:0,k),null!=b&&n.disposeData(b.dataId),g}};let Bn;const Hn={kernelName:t.ResizeBilinearGrad,backendName:"wasm",setupFunc:function(e){Bn=e.wasm.cwrap(t.ResizeBilinearGrad,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:u}=t,{alignCorners:i}=a,s=n.makeOutput(r.shape,"float32");let o,d=n.dataIdMap.get(r.dataId);return"float32"!==d.dtype&&(o=ue({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),d=n.dataIdMap.get(o.dataId)),Bn(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,n.dataIdMap.get(s.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(u.shape).buffer),i),null!=o&&n.disposeData(o.dataId),s}};let Ln;const Gn={kernelName:t.ResizeNearestNeighbor,backendName:"wasm",setupFunc:function(e){Ln=e.wasm.cwrap(t.ResizeNearestNeighbor,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{images:u}=a,{alignCorners:i,halfPixelCenters:s,size:o}=r,[d,l]=o,[p,c,m,f]=u.shape,h=[p,d,l,f],b=n.makeOutput(h,"float32");if(0===t.util.sizeFromShape(u.shape))return b;let _,y=n.dataIdMap.get(u.dataId);"float32"!==y.dtype&&(_=ue({backend:n,inputs:{x:u},attrs:{dtype:"float32"}}),y=n.dataIdMap.get(_.dataId));const g=y.id,k=n.dataIdMap.get(b.dataId).id;return Ln(g,p,c,m,f,d,l,i?1:0,s?1:0,k),null!=_&&n.disposeData(_.dataId),b}};let Un;const jn={kernelName:t.ResizeNearestNeighborGrad,backendName:"wasm",setupFunc:function(e){Un=e.wasm.cwrap(t.ResizeNearestNeighborGrad,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:u}=t,{alignCorners:i}=a,s=n.makeOutput(r.shape,"float32");let o,d=n.dataIdMap.get(r.dataId);return"float32"!==d.dtype&&(o=ue({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),d=n.dataIdMap.get(o.dataId)),Un(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,n.dataIdMap.get(s.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(u.shape).buffer),i),null!=o&&n.disposeData(o.dataId),s}};let qn;const Vn={kernelName:t.Reverse,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{dims:i}=r,s=t.util.parseAxisParam(i,u.shape);if(0===u.shape.length)return g({inputs:{x:u},backend:a});const o=a.makeOutput(u.shape,u.dtype),d=a.dataIdMap.get(u.dataId).id,l=a.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(s).buffer),c=new Uint8Array(new Int32Array(u.shape).buffer);qn(d,p,s.length,c,u.shape.length,l);const m=q({inputs:{x:o},attrs:{shape:u.shape},backend:a});return a.disposeData(o.dataId),m},setupFunc:function(e){qn=e.wasm.cwrap(t.Reverse,null,["number","array","number","array","number","number"])}};let $n;const Kn={kernelName:t.RotateWithOffset,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{image:u}=n,{radians:i,fillValue:s,center:o}=r,d=a.makeOutput(u.shape,u.dtype),l=a.dataIdMap.get(u.dataId).id,p=a.dataIdMap.get(d.dataId).id,[c,m,f,h]=u.shape,[b,_]=t.backend_util.getImageCenter(o,m,f),y="number"==typeof s?[s,s,s,0===s?0:255]:[...s,255],g=new Uint8Array(new Int32Array(y).buffer);return $n(l,c,m,f,h,i,b,_,g,y.length,p),d},setupFunc:function(e){$n=e.wasm.cwrap(t.RotateWithOffset,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Xn=p(t.Round),Qn=p(t.Rsqrt);let Jn;const Zn={kernelName:t.ScatterNd,backendName:"wasm",setupFunc:function(e){Jn=e.wasm.cwrap(t.ScatterNd,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{indices:u,updates:i}=a,{shape:o}=r,d=n.makeOutput(o,i.dtype);if(0===t.util.sizeFromShape(o))return d;const{sliceRank:l,numUpdates:p,sliceSize:c,strides:m,outputSize:f}=t.scatter_util.calculateShapes(i,u,o),h=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(i.dataId).id,_=new Uint8Array(new Int32Array(m).buffer),y=n.dataIdMap.get(d.dataId).id;return Jn(h,b,s[i.dtype],l,p,c,_,f,y),d}};let Yn;const ea={kernelName:t.SearchSorted,backendName:"wasm",setupFunc:function(e){Yn=e.wasm.cwrap(t.SearchSorted,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:u}=t,{side:i}=a;if(r.dtype!==u.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${u.dtype}`);const o=n.makeOutput(u.shape,"int32");function d(e){return n.dataIdMap.get(e.dataId).id}return Yn(d(r),d(u),r.shape[0],r.shape[1],u.shape[1],s[r.dtype],"left"===i,d(o)),o}};let ta;const na={kernelName:t.Select,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a}=e,{condition:r,t:u,e:i}=n,s=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(u.dataId).id,d=a.dataIdMap.get(i.dataId).id,l=a.makeOutput(u.shape,u.dtype),p=a.dataIdMap.get(l.dataId).id,c=r.shape.length,m=u.shape.length,f=0===c||c>1||1===m?1:t.util.sizeFromShape(u.shape.slice(1));return ta(s,o,d,f,p),l},setupFunc:function(e){ta=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},aa=p(t.Selu);let ra;const ua={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){ra=e.wasm.cwrap(t.Sigmoid,null,["number","number"])},kernelFunc:function(e){const{backend:n,inputs:{x:a}}=e,r=n.dataIdMap.get(a.dataId).id,u=n.makeOutput(a.shape,a.dtype),i=n.dataIdMap.get(u.dataId).id;return 0===t.util.sizeFromShape(u.shape)||ra(r,i),u}},ia=p(t.Sign),sa=p(t.Sin),oa=p(t.Sinh),da=p(t.Softplus),la={kernelName:t.SpaceToBatchND,backendName:"wasm",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:u}=n,{blockShape:i,paddings:s}=r,o=t.util.sizeFromShape(i),d=[[0,0]];d.push(...s);for(let e=1+i.length;e<u.shape.length;++e)d.push([0,0]);const l=vn.kernelFunc({inputs:{x:u},backend:a,attrs:{paddings:d,constantValue:0}}),p=t.backend_util.getReshaped(l.shape,i,o,!1),c=t.backend_util.getPermuted(p.length,i.length,!1),m=t.backend_util.getReshapedPermuted(l.shape,i,o,!1),f=q({inputs:{x:l},backend:a,attrs:{shape:p}}),h=w({inputs:{x:f},backend:a,attrs:{perm:c}}),b=q({inputs:{x:h},backend:a,attrs:{shape:m}});return a.disposeData(l.dataId),a.disposeData(f.dataId),a.disposeData(h.dataId),b}};let pa;const ca={kernelName:t.SparseFillEmptyRows,backendName:"wasm",setupFunc:function(e){pa=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a}=e,{indices:r,values:u,denseShape:i,defaultValue:o}=a,d=r.shape[0],l=r.shape[1],p=n.readSync(i.dataId)[0],c=[d+p,l],m=n.dataIdMap.get(r.dataId).id,f=n.dataIdMap.get(u.dataId).id,h=n.dataIdMap.get(o.dataId).id,b=n.makeOutput(c,r.dtype),_=n.dataIdMap.get(b.dataId).id,y=n.makeOutput(c.slice(0,1),u.dtype),g=n.dataIdMap.get(y.dataId).id,k=n.makeOutput([p],"bool"),I=n.dataIdMap.get(k.dataId).id,w=n.makeOutput([d],r.dtype),M=n.dataIdMap.get(w.dataId).id,S=n.makeOutput([4],"int32"),A=n.dataIdMap.get(S.dataId).id,v=pa(m,f,s[u.dtype],d,p,l,h,_,g,I,M,A),x=n.readSync(S.dataId);let F;switch(x[0]){case 1:F=t.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(x[1]);break;case 2:F=t.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(x[1],x[2]);break;case 3:F=t.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(x[1],x[2],x[3]);break;default:F=""}if(n.disposeData(S.dataId),F)throw n.disposeData(b.dataId),n.disposeData(y.dataId),n.disposeData(k.dataId),n.disposeData(w.dataId),new Error(F);let N=b,D=y;return v!==c[0]&&(N=Z({inputs:{x:b},attrs:{begin:0,size:[v,l]},backend:n}),D=Z({inputs:{x:y},attrs:{begin:0,size:v},backend:n}),n.disposeData(b.dataId),n.disposeData(y.dataId)),[N,D,k,w]}};let ma;const fa={kernelName:t.SparseReshape,backendName:"wasm",setupFunc:function(e){ma=e.wasm.cwrap(t.SparseReshape,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a}=e,{inputIndices:r,inputShape:u,newShape:i}=a;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==u.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${u.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(i.dataId).id,l=r.shape[0],p=t.util.sizeFromShape(i.shape),c=n.makeOutput([l,p],r.dtype),m=n.dataIdMap.get(c.dataId).id,f=n.makeOutput([p],i.dtype),h=n.dataIdMap.get(f.dataId).id,b=n.makeOutput([3],"int32"),_=n.dataIdMap.get(b.dataId).id;ma(s,o,d,l,m,h,_);const y=n.readSync(b.dataId);let g;switch(y[0]){case 0:g=t.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break;case 1:g=t.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break;case 2:g=t.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const e=Array.from(n.readSync(u.dataId)),a=Array.from(n.readSync(f.dataId));g=t.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(e,a);break}case 4:{const e=Array.from(n.readSync(u.dataId)),a=Array.from(n.readSync(f.dataId));g=t.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(e,a);break}default:g=""}if(n.disposeData(b.dataId),g)throw n.disposeData(c.dataId),n.disposeData(f.dataId),new Error(g);return[c,f]}};let ha;function ba(e){ha=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function _a(e,n){const{backend:a,inputs:r}=e,{data:u,indices:i,segmentIds:o}=r,d=i.shape[0],l=a.readSync(o.dataId,d-1,d)[0],p=d>0?l+1:0;if(p<0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const c=u.shape.slice();c[0]=p;const m=a.dataIdMap.get(u.dataId).id,f=a.dataIdMap.get(i.dataId).id,h=a.dataIdMap.get(o.dataId).id,b=a.makeOutput(c,u.dtype),_=a.dataIdMap.get(b.dataId).id,y=a.makeOutput([4],"int32"),g=a.dataIdMap.get(y.dataId).id;ha(m,s[u.dtype],u.shape[0],f,h,_,g,n,0);const k=a.readSync(y.dataId);let I;switch(k[0]){case 0:I=t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:I=t.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:I=t.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(k[1],k[2]);break;case 3:I=t.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(k[1],k[2],k[3]);break;default:I=""}if(a.disposeData(y.dataId),I)throw a.disposeData(b.dataId),new Error(I);return b}const ya={kernelName:t.SparseSegmentMean,backendName:"wasm",setupFunc:ba,kernelFunc:function(e){return _a(e,!0)}},ga={kernelName:t.SparseSegmentSum,backendName:"wasm",setupFunc:ba,kernelFunc:function(e){return _a(e,!1)}};let ka;const Ia={kernelName:t.SparseToDense,backendName:"wasm",setupFunc:function(e){ka=e.wasm.cwrap(t.SparseToDense,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{sparseIndices:u,sparseValues:i,defaultValue:o}=a,{outputShape:d}=r,l=n.makeOutput(d,o.dtype);if(0===t.util.sizeFromShape(d))return l;const{sliceRank:p,numUpdates:c,sliceSize:m,strides:f,outputSize:h}=t.backend_util.calculateShapes(i,u,d),b=n.dataIdMap.get(u.dataId).id,_=n.dataIdMap.get(i.dataId).id,y=n.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(f).buffer),k=n.dataIdMap.get(l.dataId).id;return ka(b,_,i.shape.length,y,s[o.dtype],p,c,m,g,h,k),l}},wa={kernelName:t.SplitV,backendName:"wasm",kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,{x:u}=n,{numOrSizeSplits:i,axis:s}=a,o=t.util.parseAxisParam(s,u.shape)[0],d=t.backend_util.prepareSplitSize(u,i,o),l=new Array(u.shape.length).fill(0),p=u.shape.slice();return d.map((e=>{const t=[...p];t[o]=e;const n=Z({inputs:{x:u},attrs:{begin:l,size:t},backend:r});return l[o]+=e,n}))}},Ma=p(t.Sqrt),Sa=p(t.Square),Aa=h(t.SquaredDifference);let va;const xa={kernelName:t.Step,backendName:"wasm",setupFunc:function(e){va=e.wasm.cwrap(t.Step,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:u}=n,i=t.dataIdMap.get(u.dataId).id,o=t.makeOutput(u.shape,u.dtype),d=t.dataIdMap.get(o.dataId).id;return va(i,r,s[u.dtype],d),o}};let Fa;const Na={kernelName:t.StridedSlice,backendName:"wasm",setupFunc:function(e){Fa=e.wasm.cwrap(t.StridedSlice,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{x:u}=a,{begin:i,end:s,strides:o,beginMask:d,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=r,{finalShapeSparse:f,finalShape:h,isIdentity:b,sliceDim0:_,isSimpleSlice:y,begin:g,end:k,strides:I}=t.slice_util.sliceInfo(u.shape,i,s,o,d,l,p,c,m);let w;if(b)w=q({inputs:{x:u},backend:n,attrs:{shape:h}});else if(_||y){t.util.assert(u.shape.length>=1,(()=>`Input must have rank at least 1, got: ${u.shape.length}`));const e=t.slice_util.computeOutShape(g,k,I),a=Z({inputs:{x:u},backend:n,attrs:{begin:g,size:e}});w=q({inputs:{x:a},backend:n,attrs:{shape:h}}),n.disposeData(a.dataId)}else{const e=n.makeOutput(f,"float32"),a=n.dataIdMap.get(u.dataId).id,r=new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),i=new Uint8Array(new Int32Array(g).buffer),s=new Uint8Array(new Int32Array(k).buffer),o=new Uint8Array(new Int32Array(I).buffer),d=new Uint8Array(new Int32Array(f).buffer),l=new Uint8Array(new Int32Array(t.util.computeStrides(f)).buffer),p=n.dataIdMap.get(e.dataId).id;Fa(a,r,u.shape.length,i,s,o,d,l,f.length,p),w=q({inputs:{x:e},backend:n,attrs:{shape:h}}),n.disposeData(e.dataId)}return w}},Da={kernelName:t.StringNGrams,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:u}=n,{separator:i,nGramWidths:s,leftPad:o,rightPad:d,padWidth:l,preserveShortSequences:p}=a,c=t.readSync(r.dataId),m=t.readSync(u.dataId),[f,h]=function(e,t,n,a,r,u,i,s){return new Q(n,a,r,u,i,s).compute(e,t)}(c,m,i,s,o,d,l,p),b=t.makeOutput([f.length],"string");t.dataIdMap.get(b.dataId).stringBytes=f;const _=t.makeOutput(u.shape,"int32");return t.typedArrayFromHeap(_).set(h),[b,_]}},Ra={kernelName:t.StringSplit,backendName:"wasm",kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{input:u,delimiter:i}=a,{skipEmpty:s}=r,o=n.readSync(u.dataId),d=n.readSync(i.dataId),[l,p,c]=function(e,n,a){const r=e.length,u=[];let i=0,s=0;const o=new Array(r);for(let t=0;t<r;++t){const r=u.length;J(e[t],n,a,u);const d=u.length-r;o[t]=d,i+=d,s=Math.max(s,d)}const d=t.util.getArrayFromDType("int32",2*i),l=new Array(i),p=[r,s];let c=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)d[2*c]=e,d[2*c+1]=t,l[c]=u[c],++c;return[d,l,p]}(o,d[0],s),m=p.length,f=n.makeOutput([m,2],"int32");n.typedArrayFromHeap(f).set(l);const h=n.makeOutput([m],"string");n.dataIdMap.get(h.dataId).stringBytes=p;const b=n.makeOutput([2],"int32");return n.typedArrayFromHeap(b).set(c),[f,h,b]}},Ea={kernelName:t.StringToHashBucketFast,backendName:"wasm",kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{input:u}=a,{numBuckets:i}=r,s=function(e,n){const a=t.util.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)a[r]=t.util.fingerPrint64(e[r]).modulo(n).getLowBitsUnsigned();return a}(n.readSync(u.dataId),i),o=n.makeOutput(u.shape,"int32");return n.typedArrayFromHeap(o).set(s),o}},Pa=h(t.Sub);let Ca;const Wa={kernelName:t.Sum,backendName:"wasm",setupFunc:function(e){Ca=e.wasm.cwrap(t.Sum,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:u,keepDims:i}=r,{x:o}=a,d=n.dataIdMap.get(o.dataId).id;let l=d,p=o;const{transposed:c,axes:m,originalAxes:f,inputWasTransposed:h}=S(o,u,n);let b=m;if(h){const e=n.dataIdMap.get(c.dataId).id;e!==d&&(p=c,l=e,b=t.backend_util.getInnerMostAxes(b.length,p.shape.length))}t.backend_util.assertAxesAreInnerMostDims("sum",b,p.shape.length);const[_,y]=t.backend_util.computeOutAndReduceShapes(p.shape,b),g=t.util.sizeFromShape(y),k=n.makeOutput(_,p.dtype);if(0!==t.util.sizeFromShape(p.shape)){const e=n.dataIdMap.get(k.dataId).id;Ca(l,g,s[k.dtype],e)}if(h&&n.disposeData(c.dataId),i){const e=t.backend_util.expandShapeToKeepDim(k.shape,f);k.shape=e}return k}},Oa=p(t.Tan),Ta=p(t.Tanh);let za;const Ba={kernelName:t.TensorScatterUpdate,backendName:"wasm",setupFunc:function(e){za=e.wasm.cwrap(t.TensorScatterUpdate,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{tensor:u,indices:i,updates:o}=a,d=n.makeOutput(u.shape,u.dtype);if(0===t.util.sizeFromShape(u.shape))return d;const{sliceRank:l,numUpdates:p,sliceSize:c,strides:m,outputSize:f}=t.scatter_util.calculateShapes(o,i,u.shape),h=n.dataIdMap.get(i.dataId).id,b=n.dataIdMap.get(o.dataId).id,_=n.dataIdMap.get(u.dataId).id,y=new Uint8Array(new Int32Array(m).buffer),g=n.dataIdMap.get(d.dataId).id;return za(h,b,s[o.dtype],l,p,c,y,f,g,_),d}};let Ha;const La={kernelName:t.Tile,backendName:"wasm",setupFunc:function(e){Ha=e.wasm.cwrap(t.Tile,null,["number","array","number","array","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,u=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let e=0;e<o.length;e++)o[e]=r.shape[e]*i[e];const d=new Uint8Array(new Int32Array(r.shape).buffer),l=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,r.dtype),c=n.dataIdMap.get(p.dataId).id;return Ha(u,d,r.shape.length,l,o.length,s[p.dtype],c),p}};let Ga;const Ua={kernelName:t.TopK,backendName:"wasm",setupFunc:function(e){Ga=e.wasm.cwrap(t.TopK,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{k:r,sorted:u}=n,i=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),d=a.shape.slice();d[d.length-1]=r;const l=t.makeOutput(d,a.dtype),p=t.dataIdMap.get(l.dataId).id,c=t.makeOutput(d,"int32"),m=t.dataIdMap.get(c.dataId).id;return Ga(i,o,a.shape.length,s[a.dtype],r,u,p,m),[l,c]}};let ja;const qa={kernelName:t.Transform,backendName:"wasm",setupFunc:function(e){ja=e.wasm.cwrap(t.Transform,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{image:u,transforms:i}=a,{interpolation:s,fillMode:o,fillValue:d,outputShape:l}=r,[p,c,m,f]=u.shape,[h,b]=null!=l?l:[c,m],_=[p,h,b,f],y=new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),g=new Uint8Array(new Int32Array(t.util.computeStrides(_)).buffer),k=n.makeOutput(_,u.dtype),I=n.dataIdMap.get(k.dataId).id,w=n.dataIdMap.get(u.dataId).id,M=n.dataIdMap.get(i.dataId).id,S="nearest"===s?1:2;let A;switch(o){case"constant":default:A=1;break;case"reflect":A=2;break;case"wrap":A=3;break;case"nearest":A=4}return ja(w,M,i.shape[0]>1,p,h,b,f,m,c,y,u.shape.length-1,g,_.length-1,S,A,d,I),k}},Va={kernelName:t.Unique,backendName:"wasm",kernelFunc:function(e){const{inputs:n,attrs:a,backend:r}=e,{axis:u}=a,{x:i}=n,{outputValues:s,outputShape:o,indices:d}=function(e,n,a,r){const u=t.util.parseAxisParam(n,a)[0],i=[1,a[0],1];for(let e=0;e<u;e++)i[0]*=a[e];i[1]=a[u];for(let e=u+1;e<a.length;e++)i[2]*=a[e];const s=new Map,o=new Int32Array(a[u]),d=new t.TensorBuffer(i,r,e),l=[],p=1===i[0]&&1===i[2];for(let t=0;t<a[u];t++){let n;if(p)n=e[t].toString();else{const e=[];for(let n=0;n<i[0];n++)for(let a=0;a<i[2];a++)e.push(d.get(n,t,a));n=e.join(",")}const a=s.get(n);if(null!=a)o[t]=a;else{const e=s.size;s.set(n,e),o[t]=e,l.push(t)}}const c=i.slice();c[1]=s.size;const m=new t.TensorBuffer(c,r);l.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let a=0;a<i[2];a++)m.set(d.get(n,e,a),n,t,a)}));const f=a.slice();return f[u]=c[1],{outputValues:m.values,outputShape:f,indices:o}}(r.readSync(i.dataId),u,i.shape,i.dtype);return[r.makeOutput(o,i.dtype,void 0,s),r.makeOutput([d.length],"int32",void 0,d)]}},$a={kernelName:t.Unpack,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:u}=a;u<0&&(u+=r.shape.length);const i=r.shape[u],s=r.shape.length,o=new Array(s-1);let d=0;for(let e=0;e<s;e++)e!==u&&(o[d++]=r.shape[e]);const l=new Array(i),p=new Array(s).fill(0),c=r.shape.slice();c[u]=1;for(let e=0;e<l.length;e++)p[u]=e,l[e]=Z({inputs:{x:r},attrs:{begin:p,size:c},backend:n});return l.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:o})))}},Ka={kernelName:t.ZerosLike,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}},Xa=[l,c,m,f,b,y,v,F,D,R,E,P,C,W,O,z,j,H,G,K,ee,ne,ae,re,ie,se,de,pe,me,he,_e,ge,Ie,we,Me,ve,Fe,De,Ee,Ce,Oe,ze,He,Ge,je,qe,$e,Ke,Xe,Qe,Ze,Ye,tt,at,rt,ut,st,dt,pt,mt,ht,bt,_t,k,yt,gt,kt,wt,Mt,St,vt,Ft,xt,Nt,Dt,Rt,Et,Ct,Ot,zt,Bt,Lt,Ut,qt,$t,Xt,Jt,Yt,en,an,dn,ln,pn,cn,hn,_n,gn,kn,wn,Mn,Sn,vn,xn,Nn,Rn,En,Pn,Cn,Wn,On,V,zn,Hn,Gn,jn,Vn,Kn,Xn,Qn,Zn,ea,na,aa,ua,ia,sa,oa,Y,sn,da,la,ca,fa,ya,ga,Ia,wa,Ma,Sa,Aa,xa,Na,Da,Ra,Ea,Pa,Wa,Oa,Ta,Ba,La,Ua,qa,M,Va,$a,Ka];for(const e of Xa)t.registerKernel(e);const Qa=t.env();Qa.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}})),Qa.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Qa.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var Ja="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function Za(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Ya={exports:{}};!function(e){var t,i=(t="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(t=t||__filename),function(e){function i(){return E.buffer!=O&&q(E.buffer),z}function s(){return E.buffer!=O&&q(E.buffer),B}function o(){return E.buffer!=O&&q(E.buffer),H}function d(){return E.buffer!=O&&q(E.buffer),L}var l,p,c,m=void 0!==(e=e||{})?e:{};m.ready=new Promise((function(e,t){l=e,p=t})),"undefined"!=typeof process&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f,h,b,_=Object.assign({},m),y=(e,t)=>{throw t},g="object"==typeof window,k="function"==typeof importScripts,I="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,w=m.ENVIRONMENT_IS_PTHREAD||!1,M="";function S(e){return m.locateFile?m.locateFile(e,M):M+e}if(I){var A=n,v=a;let t;M=k?v.dirname(M)+"/":__dirname+"/",f=(e,t)=>(e=re(e)?new URL(e):v.normalize(e),A.readFileSync(e,t?void 0:"utf8")),b=e=>{var t=f(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{e=re(e)?new URL(e):v.normalize(e),A.readFile(e,(function(e,a){e?n(e):t(a.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof se))throw e})),process.on("unhandledRejection",(function(e){throw e})),y=(e,t)=>{if(J())throw process.exitCode=e,t;var n;(n=t)instanceof se||R("exiting due to exception: "+n),process.exit(e)},m.inspect=function(){return"[Emscripten Module object]"};try{t=require("worker_threads")}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}Ja.Worker=t.Worker}else(g||k)&&(k?M=self.location.href:"undefined"!=typeof document&&document.currentScript&&(M=document.currentScript.src),void 0!==t&&t&&(M=t),M=0!==M.indexOf("blob:")?M.substr(0,M.replace(/[?#].*/,"").lastIndexOf("/")+1):"",I||(f=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},k&&(b=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)}));I&&"undefined"==typeof performance&&(Ja.performance=r.performance);var x=console.log.bind(console),F=console.warn.bind(console);I&&(x=e=>A.writeSync(1,e+"\n"),F=e=>A.writeSync(2,e+"\n"));var N,D=m.print||x,R=m.printErr||F;Object.assign(m,_),_=null,m.arguments&&m.arguments,m.thisProgram&&m.thisProgram,m.quit&&(y=m.quit),m.wasmBinary&&(N=m.wasmBinary);var E,P,C=m.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var W,O,T,z,B,H,L,G=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function j(e,t,n){for(var a=(t>>>=0)+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.buffer&&U)return U.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(var u="";t<r;){var i=e[t++];if(128&i){var s=63&e[t++];if(192!=(224&i)){var o=63&e[t++];if((i=224==(240&i)?(15&i)<<12|s<<6|o:(7&i)<<18|s<<12|o<<6|63&e[t++])<65536)u+=String.fromCharCode(i);else{var d=i-65536;u+=String.fromCharCode(55296|d>>10,56320|1023&d)}}else u+=String.fromCharCode((31&i)<<6|s)}else u+=String.fromCharCode(i)}return u}function q(e){O=e,m.HEAP8=T=new Int8Array(e),m.HEAP16=new Int16Array(e),m.HEAP32=B=new Int32Array(e),m.HEAPU8=z=new Uint8Array(e),m.HEAPU16=new Uint16Array(e),m.HEAPU32=H=new Uint32Array(e),m.HEAPF32=new Float32Array(e),m.HEAPF64=L=new Float64Array(e)}w&&(O=m.buffer);var V,$=m.INITIAL_MEMORY||16777216;if(w)E=m.wasmMemory,O=m.buffer;else if(m.wasmMemory)E=m.wasmMemory;else if(!((E=new WebAssembly.Memory({initial:$/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");E&&(O=E.buffer),$=O.byteLength,q(O);var K=[],X=[],Q=[];function J(){return C}function Z(){w||me(X)}var Y,ee=0,te=null;function ne(e){m.onAbort&&m.onAbort(e),R(e="Aborted("+e+")"),G=!0,W=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw p(t),t}function ae(e){return e.startsWith("data:application/octet-stream;base64,")}function re(e){return e.startsWith("file://")}function ue(e){try{if(e==Y&&N)return new Uint8Array(N);if(b)return b(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}ae(Y="tfjs-backend-wasm-threaded-simd.wasm")||(Y=S(Y));var ie={};function se(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function oe(e){var t=ce.pthreads[e];t||ne(void 0),ce.returnWorkerToPool(t)}function de(e){var t=ce.getNewWorker();if(!t)return 6;ce.runningWorkers.push(t),ce.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{I&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function le(e){if(w)return Ie(1,1,e);W=e,J()||(ce.terminateAllThreads(),m.onExit&&m.onExit(e),G=!0),y(e,new se(e))}var pe=function(e,t){if(W=e,!t&&w)throw fe(e),"unwind";le(e)},ce={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){w?ce.initWorker():ce.initMainThread()},initMainThread:function(){for(var e=8;e--;)ce.allocateUnusedWorker()},initWorker:function(){C=!1},setExitStatus:function(e){W=e},terminateAllThreads:function(){for(var e of Object.values(ce.pthreads))ce.returnWorkerToPool(e);for(var e of ce.unusedWorkers)e.terminate();ce.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete ce.pthreads[t],ce.unusedWorkers.push(e),ce.runningWorkers.splice(ce.runningWorkers.indexOf(e),1),e.pthread_ptr=0,I&&e.unref(),Be(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){ce.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(e,n){e.onmessage=t=>{var a,r=t.data,u=r.cmd;if(e.pthread_ptr&&(ce.currentProxiedOperationCallerThread=e.pthread_ptr),r.targetThread&&r.targetThread!=Ee()){var i=ce.pthreads[r.targetThread];return i?i.postMessage(r,r.transferList):R('Internal error! Worker sent a message "'+u+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(ce.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===u?ge(r.queue):"spawnThread"===u?de(r):"cleanupThread"===u?oe(r.thread):"killThread"===u?function(e){var t=ce.pthreads[e];delete ce.pthreads[e],t.terminate(),Be(e),ce.runningWorkers.splice(ce.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===u?(a=r.thread,ce.pthreads[a].postMessage({cmd:"cancel"})):"loaded"===u?(e.loaded=!0,I&&e.unref(),n&&n(e),e.runPthread&&e.runPthread()):"print"===u?D("Thread "+r.threadId+": "+r.text):"printErr"===u?R("Thread "+r.threadId+": "+r.text):"alert"===u?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===u?m[r.handler](...r.args):u&&R("worker sent an unknown command "+u),ce.currentProxiedOperationCallerThread=void 0},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},I&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){})));var a=[];for(var r of["onExit","onAbort","print","printErr"])m.hasOwnProperty(r)&&a.push(r);e.postMessage({cmd:"load",handlers:a,urlOrBlob:m.mainScriptUrlOrBlob||t,wasmMemory:E,wasmModule:P})},allocateUnusedWorker:function(){var e,t=S("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),ce.unusedWorkers.push(e)},getNewWorker:function(){return 0==ce.unusedWorkers.length&&(ce.allocateUnusedWorker(),ce.loadWasmModuleToWorker(ce.unusedWorkers[0])),ce.unusedWorkers.pop()}};function me(e){for(;e.length>0;)e.shift()(m)}function fe(e){if(w)return Ie(2,0,e);try{pe(e)}catch(e){!function(e){if(e instanceof se||"unwind"==e)return W;y(1,e)}(e)}}m.PThread=ce,m.establishStackSpace=function(){var e=Ee(),t=s()[e+52>>>2],n=s()[e+56>>>2];Le(t,t-n),Ue(t)};var he,be=[];function _e(e,t,n,a){return w?Ie(3,1,e,t,n,a):ye(e,t,n,a)}function ye(e,t,n,a){if("undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var r=[];if(w&&0===r.length)return _e(e,t,n,a);var u={startRoutine:n,pthread_ptr:e,arg:a,transferList:r};return w?(u.cmd="spawnThread",postMessage(u,r),0):de(u)}function ge(e){Atomics.store(s(),e>>2,1),Ee()&&ze(e),Atomics.compareExchange(s(),e>>2,1,0)}function ke(e){ke.shown||(ke.shown={}),ke.shown[e]||(ke.shown[e]=1,I&&(e="warning: "+e),R(e))}function Ie(e,t){var n=arguments.length-2,a=arguments;return function(e){var t=Ge(),n=e();return Ue(t),n}((()=>{for(var r=n,u=je(8*r),i=u>>3,s=0;s<n;s++){var o=a[2+s];d()[i+s>>>0]=o}return Ce(e,r,u,t)}))}m.invokeEntryPoint=function(e,t){var n,a,r=((a=be[n=e])||(n>=be.length&&(be.length=n+1),be[n]=a=V.get(n)),a)(t);J()?ce.setExitStatus(r):He(r)},m.executeNotifiedProxyingQueue=ge,he=I?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var we=[];function Me(e){try{return E.grow(e-O.byteLength+65535>>>16),q(E.buffer),1}catch(e){}}function Se(e){return w?Ie(4,1,e):52}function Ae(e,t,n,a,r){return w?Ie(5,1,e,t,n,a,r):70}var ve=[null,[],[]];function xe(e,t){var n=ve[e];0===t||10===t?((1===e?D:R)(j(n,0)),n.length=0):n.push(t)}function Fe(e,t,n,a){if(w)return Ie(6,1,e,t,n,a);for(var r=0,u=0;u<n;u++){var s=o()[t>>>2],d=o()[t+4>>>2];t+=8;for(var l=0;l<d;l++)xe(e,i()[s+l>>>0]);r+=d}return o()[a>>>2]=r,0}function Ne(e){return m["_"+e]}ce.init();var De=[null,le,fe,_e,Se,Ae,Fe],Re={__emscripten_init_main_thread_js:function(e){Pe(e,!k,1,!g),ce.threadInitTLS()},__emscripten_thread_cleanup:function(e){w?postMessage({cmd:"cleanupThread",thread:e}):oe(e)},__pthread_create_js:ye,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(e,t,n,a){if(e==t)setTimeout((()=>ge(a)));else if(w)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:a});else{var r=ce.pthreads[e];if(!r)return;r.postMessage({cmd:"processProxyingQueue",queue:a})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){ne("")},emscripten_check_blocking_allowed:function(){I||k||ke("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:he,emscripten_memcpy_big:function(e,t,n){i().copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_num_logical_cores:function(){return I?u.cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){we.length=t;for(var a=n>>3,r=0;r<t;r++)we[r]=d()[a+r>>>0];return(e<0?ie[-e-1]:De[e]).apply(null,we)},emscripten_resize_heap:function(e){var t=i().length;if((e>>>=0)<=t)return!1;var n,a=4294901760;if(e>a)return!1;for(var r=1;r<=4;r*=2){var u=t*(1+.2/r);if(u=Math.min(u,e+100663296),Me(Math.min(a,(n=Math.max(e,u))+(65536-n%65536)%65536)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:pe,fd_close:Se,fd_seek:Ae,fd_write:Fe,memory:E||m.wasmMemory};!function(){var e={env:Re,wasi_snapshot_preview1:Re};function t(e,t){var n,a,r=e.exports;if(m.asm=r,n=m.asm._emscripten_tls_init,ce.tlsInitFunctions.push(n),V=m.asm.__indirect_function_table,a=m.asm.__wasm_call_ctors,X.unshift(a),P=t,!w){var u=ce.unusedWorkers.length;ce.unusedWorkers.forEach((function(e){ce.loadWasmModuleToWorker(e,(function(){--u||function(){if(ee--,m.monitorRunDependencies&&m.monitorRunDependencies(ee),0==ee&&te){var e=te;te=null,e()}}()}))}))}}function n(e){t(e.instance,e.module)}function a(t){return function(){if(!N&&(g||k)){if("function"==typeof fetch&&!re(Y))return fetch(Y,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Y+"'";return e.arrayBuffer()})).catch((function(){return ue(Y)}));if(h)return new Promise((function(e,t){h(Y,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ue(Y)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){R("failed to asynchronously prepare wasm: "+e),ne(e)}))}if(w||(ee++,m.monitorRunDependencies&&m.monitorRunDependencies(ee)),m.instantiateWasm)try{return m.instantiateWasm(e,t)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),p(e)}(N||"function"!=typeof WebAssembly.instantiateStreaming||ae(Y)||re(Y)||I||"function"!=typeof fetch?a(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return R("wasm streaming compile failed: "+e),R("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(p)}(),m.___wasm_call_ctors=function(){return(m.___wasm_call_ctors=m.asm.__wasm_call_ctors).apply(null,arguments)},m._init=function(){return(m._init=m.asm.init).apply(null,arguments)},m._init_with_threads_count=function(){return(m._init_with_threads_count=m.asm.init_with_threads_count).apply(null,arguments)},m._get_threads_count=function(){return(m._get_threads_count=m.asm.get_threads_count).apply(null,arguments)},m._register_tensor=function(){return(m._register_tensor=m.asm.register_tensor).apply(null,arguments)},m._dispose_data=function(){return(m._dispose_data=m.asm.dispose_data).apply(null,arguments)},m._dispose=function(){return(m._dispose=m.asm.dispose).apply(null,arguments)},m._Abs=function(){return(m._Abs=m.asm.Abs).apply(null,arguments)},m._Acos=function(){return(m._Acos=m.asm.Acos).apply(null,arguments)},m._Acosh=function(){return(m._Acosh=m.asm.Acosh).apply(null,arguments)},m._Add=function(){return(m._Add=m.asm.Add).apply(null,arguments)},m._AddN=function(){return(m._AddN=m.asm.AddN).apply(null,arguments)},m._All=function(){return(m._All=m.asm.All).apply(null,arguments)},m._Any=function(){return(m._Any=m.asm.Any).apply(null,arguments)},m._ArgMax=function(){return(m._ArgMax=m.asm.ArgMax).apply(null,arguments)},m._ArgMin=function(){return(m._ArgMin=m.asm.ArgMin).apply(null,arguments)},m._Asin=function(){return(m._Asin=m.asm.Asin).apply(null,arguments)},m._Asinh=function(){return(m._Asinh=m.asm.Asinh).apply(null,arguments)},m._Atan=function(){return(m._Atan=m.asm.Atan).apply(null,arguments)},m._Atan2=function(){return(m._Atan2=m.asm.Atan2).apply(null,arguments)},m._Atanh=function(){return(m._Atanh=m.asm.Atanh).apply(null,arguments)},m._AvgPool=function(){return(m._AvgPool=m.asm.AvgPool).apply(null,arguments)},m._AvgPool3D=function(){return(m._AvgPool3D=m.asm.AvgPool3D).apply(null,arguments)},m._AvgPool3DGrad=function(){return(m._AvgPool3DGrad=m.asm.AvgPool3DGrad).apply(null,arguments)},m._AvgPoolGrad=function(){return(m._AvgPoolGrad=m.asm.AvgPoolGrad).apply(null,arguments)},m._BatchMatMul=function(){return(m._BatchMatMul=m.asm.BatchMatMul).apply(null,arguments)},m._Bincount=function(){return(m._Bincount=m.asm.Bincount).apply(null,arguments)},m._BitwiseAnd=function(){return(m._BitwiseAnd=m.asm.BitwiseAnd).apply(null,arguments)},m._Ceil=function(){return(m._Ceil=m.asm.Ceil).apply(null,arguments)},m._ClipByValue=function(){return(m._ClipByValue=m.asm.ClipByValue).apply(null,arguments)},m._Conv2D=function(){return(m._Conv2D=m.asm.Conv2D).apply(null,arguments)},m._Conv2DBackpropInput=function(){return(m._Conv2DBackpropInput=m.asm.Conv2DBackpropInput).apply(null,arguments)},m._Conv3D=function(){return(m._Conv3D=m.asm.Conv3D).apply(null,arguments)},m._Conv3DBackpropFilterV2=function(){return(m._Conv3DBackpropFilterV2=m.asm.Conv3DBackpropFilterV2).apply(null,arguments)},m._Conv3DBackpropInputV2=function(){return(m._Conv3DBackpropInputV2=m.asm.Conv3DBackpropInputV2).apply(null,arguments)},m._Cos=function(){return(m._Cos=m.asm.Cos).apply(null,arguments)},m._Cosh=function(){return(m._Cosh=m.asm.Cosh).apply(null,arguments)},m._CropAndResize=function(){return(m._CropAndResize=m.asm.CropAndResize).apply(null,arguments)},m._Cumprod=function(){return(m._Cumprod=m.asm.Cumprod).apply(null,arguments)},m._Cumsum=function(){return(m._Cumsum=m.asm.Cumsum).apply(null,arguments)},m._DenseBincount=function(){return(m._DenseBincount=m.asm.DenseBincount).apply(null,arguments)},m._DepthToSpace=function(){return(m._DepthToSpace=m.asm.DepthToSpace).apply(null,arguments)},m._DepthwiseConv2dNative=function(){return(m._DepthwiseConv2dNative=m.asm.DepthwiseConv2dNative).apply(null,arguments)},m._Diag=function(){return(m._Diag=m.asm.Diag).apply(null,arguments)},m._Dilation2D=function(){return(m._Dilation2D=m.asm.Dilation2D).apply(null,arguments)},m._Dilation2DBackpropFilter=function(){return(m._Dilation2DBackpropFilter=m.asm.Dilation2DBackpropFilter).apply(null,arguments)},m._Dilation2DBackpropInput=function(){return(m._Dilation2DBackpropInput=m.asm.Dilation2DBackpropInput).apply(null,arguments)},m._Elu=function(){return(m._Elu=m.asm.Elu).apply(null,arguments)},m._EluGrad=function(){return(m._EluGrad=m.asm.EluGrad).apply(null,arguments)},m._Equal=function(){return(m._Equal=m.asm.Equal).apply(null,arguments)},m._Erf=function(){return(m._Erf=m.asm.Erf).apply(null,arguments)},m._Exp=function(){return(m._Exp=m.asm.Exp).apply(null,arguments)},m._Expm1=function(){return(m._Expm1=m.asm.Expm1).apply(null,arguments)},m._FlipLeftRight=function(){return(m._FlipLeftRight=m.asm.FlipLeftRight).apply(null,arguments)},m._Floor=function(){return(m._Floor=m.asm.Floor).apply(null,arguments)},m._FloorDiv=function(){return(m._FloorDiv=m.asm.FloorDiv).apply(null,arguments)},m._FusedBatchNorm=function(){return(m._FusedBatchNorm=m.asm.FusedBatchNorm).apply(null,arguments)},m._FusedConv2D=function(){return(m._FusedConv2D=m.asm.FusedConv2D).apply(null,arguments)},m._FusedDepthwiseConv2D=function(){return(m._FusedDepthwiseConv2D=m.asm.FusedDepthwiseConv2D).apply(null,arguments)},m._Gather=function(){return(m._Gather=m.asm.Gather).apply(null,arguments)},m._GatherNd=function(){return(m._GatherNd=m.asm.GatherNd).apply(null,arguments)},m._Greater=function(){return(m._Greater=m.asm.Greater).apply(null,arguments)},m._GreaterEqual=function(){return(m._GreaterEqual=m.asm.GreaterEqual).apply(null,arguments)},m._IsFinite=function(){return(m._IsFinite=m.asm.IsFinite).apply(null,arguments)},m._IsInf=function(){return(m._IsInf=m.asm.IsInf).apply(null,arguments)},m._IsNan=function(){return(m._IsNan=m.asm.IsNan).apply(null,arguments)},m._LRN=function(){return(m._LRN=m.asm.LRN).apply(null,arguments)},m._LRNGrad=function(){return(m._LRNGrad=m.asm.LRNGrad).apply(null,arguments)},m._LeakyRelu=function(){return(m._LeakyRelu=m.asm.LeakyRelu).apply(null,arguments)},m._Less=function(){return(m._Less=m.asm.Less).apply(null,arguments)},m._LessEqual=function(){return(m._LessEqual=m.asm.LessEqual).apply(null,arguments)},m._LinSpace=function(){return(m._LinSpace=m.asm.LinSpace).apply(null,arguments)},m._Log=function(){return(m._Log=m.asm.Log).apply(null,arguments)},m._Log1p=function(){return(m._Log1p=m.asm.Log1p).apply(null,arguments)},m._LogicalAnd=function(){return(m._LogicalAnd=m.asm.LogicalAnd).apply(null,arguments)},m._LogicalNot=function(){return(m._LogicalNot=m.asm.LogicalNot).apply(null,arguments)},m._LogicalOr=function(){return(m._LogicalOr=m.asm.LogicalOr).apply(null,arguments)},m._LogicalXor=function(){return(m._LogicalXor=m.asm.LogicalXor).apply(null,arguments)},m._Max=function(){return(m._Max=m.asm.Max).apply(null,arguments)},m._MaxPool=function(){return(m._MaxPool=m.asm.MaxPool).apply(null,arguments)},m._MaxPool3D=function(){return(m._MaxPool3D=m.asm.MaxPool3D).apply(null,arguments)},m._MaxPool3DGrad=function(){return(m._MaxPool3DGrad=m.asm.MaxPool3DGrad).apply(null,arguments)},m._MaxPoolGrad=function(){return(m._MaxPoolGrad=m.asm.MaxPoolGrad).apply(null,arguments)},m._MaxPoolWithArgmax=function(){return(m._MaxPoolWithArgmax=m.asm.MaxPoolWithArgmax).apply(null,arguments)},m._Maximum=function(){return(m._Maximum=m.asm.Maximum).apply(null,arguments)},m._Mean=function(){return(m._Mean=m.asm.Mean).apply(null,arguments)},m._Min=function(){return(m._Min=m.asm.Min).apply(null,arguments)},m._Minimum=function(){return(m._Minimum=m.asm.Minimum).apply(null,arguments)},m._MirrorPad=function(){return(m._MirrorPad=m.asm.MirrorPad).apply(null,arguments)},m._Mod=function(){return(m._Mod=m.asm.Mod).apply(null,arguments)},m._Multinomial=function(){return(m._Multinomial=m.asm.Multinomial).apply(null,arguments)},m._Multiply=function(){return(m._Multiply=m.asm.Multiply).apply(null,arguments)},m._Neg=function(){return(m._Neg=m.asm.Neg).apply(null,arguments)},m._NonMaxSuppressionV3=function(){return(m._NonMaxSuppressionV3=m.asm.NonMaxSuppressionV3).apply(null,arguments)},m._NonMaxSuppressionV4=function(){return(m._NonMaxSuppressionV4=m.asm.NonMaxSuppressionV4).apply(null,arguments)},m._NonMaxSuppressionV5=function(){return(m._NonMaxSuppressionV5=m.asm.NonMaxSuppressionV5).apply(null,arguments)},m._NotEqual=function(){return(m._NotEqual=m.asm.NotEqual).apply(null,arguments)},m._OneHot=function(){return(m._OneHot=m.asm.OneHot).apply(null,arguments)},m._PadV2=function(){return(m._PadV2=m.asm.PadV2).apply(null,arguments)},m._Pow=function(){return(m._Pow=m.asm.Pow).apply(null,arguments)},m._Prelu=function(){return(m._Prelu=m.asm.Prelu).apply(null,arguments)},m._Prod=function(){return(m._Prod=m.asm.Prod).apply(null,arguments)},m._RealDiv=function(){return(m._RealDiv=m.asm.RealDiv).apply(null,arguments)},m._Reciprocal=function(){return(m._Reciprocal=m.asm.Reciprocal).apply(null,arguments)},m._Relu=function(){return(m._Relu=m.asm.Relu).apply(null,arguments)},m._Relu6=function(){return(m._Relu6=m.asm.Relu6).apply(null,arguments)},m._ResizeBilinear=function(){return(m._ResizeBilinear=m.asm.ResizeBilinear).apply(null,arguments)},m._ResizeBilinearGrad=function(){return(m._ResizeBilinearGrad=m.asm.ResizeBilinearGrad).apply(null,arguments)},m._ResizeNearestNeighbor=function(){return(m._ResizeNearestNeighbor=m.asm.ResizeNearestNeighbor).apply(null,arguments)},m._ResizeNearestNeighborGrad=function(){return(m._ResizeNearestNeighborGrad=m.asm.ResizeNearestNeighborGrad).apply(null,arguments)},m._Reverse=function(){return(m._Reverse=m.asm.Reverse).apply(null,arguments)},m._RotateWithOffset=function(){return(m._RotateWithOffset=m.asm.RotateWithOffset).apply(null,arguments)},m._Round=function(){return(m._Round=m.asm.Round).apply(null,arguments)},m._Rsqrt=function(){return(m._Rsqrt=m.asm.Rsqrt).apply(null,arguments)},m._ScatterNd=function(){return(m._ScatterNd=m.asm.ScatterNd).apply(null,arguments)},m._SearchSorted=function(){return(m._SearchSorted=m.asm.SearchSorted).apply(null,arguments)},m._SelectV2=function(){return(m._SelectV2=m.asm.SelectV2).apply(null,arguments)},m._Selu=function(){return(m._Selu=m.asm.Selu).apply(null,arguments)},m._Sigmoid=function(){return(m._Sigmoid=m.asm.Sigmoid).apply(null,arguments)},m._Sign=function(){return(m._Sign=m.asm.Sign).apply(null,arguments)},m._Sin=function(){return(m._Sin=m.asm.Sin).apply(null,arguments)},m._Sinh=function(){return(m._Sinh=m.asm.Sinh).apply(null,arguments)},m._Softmax=function(){return(m._Softmax=m.asm.Softmax).apply(null,arguments)},m._Softplus=function(){return(m._Softplus=m.asm.Softplus).apply(null,arguments)},m._SparseFillEmptyRows=function(){return(m._SparseFillEmptyRows=m.asm.SparseFillEmptyRows).apply(null,arguments)},m._SparseReshape=function(){return(m._SparseReshape=m.asm.SparseReshape).apply(null,arguments)},m._SparseSegmentReduction=function(){return(m._SparseSegmentReduction=m.asm.SparseSegmentReduction).apply(null,arguments)},m._SparseToDense=function(){return(m._SparseToDense=m.asm.SparseToDense).apply(null,arguments)},m._Sqrt=function(){return(m._Sqrt=m.asm.Sqrt).apply(null,arguments)},m._Square=function(){return(m._Square=m.asm.Square).apply(null,arguments)},m._SquaredDifference=function(){return(m._SquaredDifference=m.asm.SquaredDifference).apply(null,arguments)},m._Step=function(){return(m._Step=m.asm.Step).apply(null,arguments)},m._StridedSlice=function(){return(m._StridedSlice=m.asm.StridedSlice).apply(null,arguments)},m._Sub=function(){return(m._Sub=m.asm.Sub).apply(null,arguments)},m._Sum=function(){return(m._Sum=m.asm.Sum).apply(null,arguments)},m._Tan=function(){return(m._Tan=m.asm.Tan).apply(null,arguments)},m._Tanh=function(){return(m._Tanh=m.asm.Tanh).apply(null,arguments)},m._TensorScatterUpdate=function(){return(m._TensorScatterUpdate=m.asm.TensorScatterUpdate).apply(null,arguments)},m._Tile=function(){return(m._Tile=m.asm.Tile).apply(null,arguments)},m._TopK=function(){return(m._TopK=m.asm.TopK).apply(null,arguments)},m._Transform=function(){return(m._Transform=m.asm.Transform).apply(null,arguments)},m._Transpose=function(){return(m._Transpose=m.asm.Transpose).apply(null,arguments)},m.__FusedMatMul=function(){return(m.__FusedMatMul=m.asm._FusedMatMul).apply(null,arguments)},m._malloc=function(){return(m._malloc=m.asm.malloc).apply(null,arguments)},m._free=function(){return(m._free=m.asm.free).apply(null,arguments)},m.__emscripten_tls_init=function(){return(m.__emscripten_tls_init=m.asm._emscripten_tls_init).apply(null,arguments)};var Ee=m._pthread_self=function(){return(Ee=m._pthread_self=m.asm.pthread_self).apply(null,arguments)};m.___errno_location=function(){return(m.___errno_location=m.asm.__errno_location).apply(null,arguments)};var Pe=m.__emscripten_thread_init=function(){return(Pe=m.__emscripten_thread_init=m.asm._emscripten_thread_init).apply(null,arguments)};m.__emscripten_thread_crashed=function(){return(m.__emscripten_thread_crashed=m.asm._emscripten_thread_crashed).apply(null,arguments)},m._emscripten_main_thread_process_queued_calls=function(){return(m._emscripten_main_thread_process_queued_calls=m.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},m._emscripten_main_browser_thread_id=function(){return(m._emscripten_main_browser_thread_id=m.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Ce=m._emscripten_run_in_main_runtime_thread_js=function(){return(Ce=m._emscripten_run_in_main_runtime_thread_js=m.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};m._emscripten_dispatch_to_thread_=function(){return(m._emscripten_dispatch_to_thread_=m.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var We,Oe,Te,ze=m.__emscripten_proxy_execute_task_queue=function(){return(ze=m.__emscripten_proxy_execute_task_queue=m.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Be=m.__emscripten_thread_free_data=function(){return(Be=m.__emscripten_thread_free_data=m.asm._emscripten_thread_free_data).apply(null,arguments)},He=m.__emscripten_thread_exit=function(){return(He=m.__emscripten_thread_exit=m.asm._emscripten_thread_exit).apply(null,arguments)},Le=m._emscripten_stack_set_limits=function(){return(Le=m._emscripten_stack_set_limits=m.asm.emscripten_stack_set_limits).apply(null,arguments)},Ge=m.stackSave=function(){return(Ge=m.stackSave=m.asm.stackSave).apply(null,arguments)},Ue=m.stackRestore=function(){return(Ue=m.stackRestore=m.asm.stackRestore).apply(null,arguments)},je=m.stackAlloc=function(){return(je=m.stackAlloc=m.asm.stackAlloc).apply(null,arguments)};function qe(e){if(!(ee>0)){if(w)return l(m),Z(),void startWorker(m);!function(){if(m.preRun)for("function"==typeof m.preRun&&(m.preRun=[m.preRun]);m.preRun.length;)e=m.preRun.shift(),K.unshift(e);var e;me(K)}(),ee>0||(m.setStatus?(m.setStatus("Running..."),setTimeout((function(){setTimeout((function(){m.setStatus("")}),1),t()}),1)):t())}function t(){We||(We=!0,m.calledRun=!0,G||(Z(),l(m),m.onRuntimeInitialized&&m.onRuntimeInitialized(),function(){if(!w){if(m.postRun)for("function"==typeof m.postRun&&(m.postRun=[m.postRun]);m.postRun.length;)e=m.postRun.shift(),Q.unshift(e);var e;me(Q)}}()))}}if(m.dynCall_iijjiiii=function(){return(m.dynCall_iijjiiii=m.asm.dynCall_iijjiiii).apply(null,arguments)},m.dynCall_jiji=function(){return(m.dynCall_jiji=m.asm.dynCall_jiji).apply(null,arguments)},m.keepRuntimeAlive=J,m.wasmMemory=E,m.cwrap=function(e,t,n,a){var r=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&r&&!a?Ne(e):function(){return function(e,t,n,a){var r={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,a){if(!(a>0))return 0;for(var r=(n>>>=0)+a-1,u=0;u<e.length;++u){var i=e.charCodeAt(u);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++u)),i<=127){if(n>=r)break;t[n++>>>0]=i}else if(i<=2047){if(n+1>=r)break;t[n++>>>0]=192|i>>6,t[n++>>>0]=128|63&i}else if(i<=65535){if(n+2>=r)break;t[n++>>>0]=224|i>>12,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}}t[n>>>0]=0}(e,i(),t,n)}(e,t=je(n),n)}return t},array:e=>{var t=je(e.length);return function(e,t){(E.buffer!=O&&q(E.buffer),T).set(e,t>>>0)}(e,t),t}},u=Ne(e),s=[],o=0;if(a)for(var d=0;d<a.length;d++){var l=r[n[d]];l?(0===o&&(o=Ge()),s[d]=l(a[d])):s[d]=a[d]}return function(e){return 0!==o&&Ue(o),function(e){return"string"===t?(n=e,(n>>>=0)?j(i(),n,void 0):""):"boolean"===t?Boolean(e):e;var n}(e)}(u.apply(null,s))}(e,t,n,arguments)}},m.ExitStatus=se,m.PThread=ce,te=function e(){We||qe(),We||(te=e)},m.preInit)for("function"==typeof m.preInit&&(m.preInit=[m.preInit]);m.preInit.length>0;)m.preInit.pop()();if(qe(),c&&(Oe={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!c.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!c.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Te=WasmBackendModule;else{if(void 0===e)throw new Error("Could not find wasm module in post.js");Te=e}if(Oe){var Ve=Te._dispose;Te._dispose=function(){Ve(),Oe.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Oe.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});e.exports=i}(Ya);var er=Ya.exports,tr=Za(er),nr=i({__proto__:null,default:tr},[er]),ar={exports:{}};!function(e){var t,r=(t="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(t=t||__filename),function(e){var r,u,i,s=void 0!==(e=e||{})?e:{};s.ready=new Promise((function(e,t){r=e,u=t})),"undefined"!=typeof process&&process.listeners&&(i={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var o,d,l,p=Object.assign({},s),c="object"==typeof window,m="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var b=n,_=a;h=m?_.dirname(h)+"/":__dirname+"/",o=(e,t)=>(e=B(e)?new URL(e):_.normalize(e),b.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=o(e,!0);return t.buffer||(t=new Uint8Array(t)),t},d=(e,t,n)=>{e=B(e)?new URL(e):_.normalize(e),b.readFile(e,(function(e,a){e?n(e):t(a.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof L))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}}else(c||m)&&(m?h=self.location.href:"undefined"!=typeof document&&document.currentScript&&(h=document.currentScript.src),t&&(h=t),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},m&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),d=(e,t,n)=>{var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)});var y,g,k=s.print||console.log.bind(console),I=s.printErr||console.warn.bind(console);Object.assign(s,p),p=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit,s.wasmBinary&&(y=s.wasmBinary),s.noExitRuntime,"object"!=typeof WebAssembly&&T("no native wasm support detected");var w,M,S,A,v=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function F(e,t,n){for(var a=(t>>>=0)+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.buffer&&x)return x.decode(e.subarray(t,r));for(var u="";t<r;){var i=e[t++];if(128&i){var s=63&e[t++];if(192!=(224&i)){var o=63&e[t++];if((i=224==(240&i)?(15&i)<<12|s<<6|o:(7&i)<<18|s<<12|o<<6|63&e[t++])<65536)u+=String.fromCharCode(i);else{var d=i-65536;u+=String.fromCharCode(55296|d>>10,56320|1023&d)}}else u+=String.fromCharCode((31&i)<<6|s)}else u+=String.fromCharCode(i)}return u}function N(e){w=e,s.HEAP8=M=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=new Int32Array(e),s.HEAPU8=S=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=A=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var D,R,E=[],P=[],C=[],W=0,O=null;function T(e){s.onAbort&&s.onAbort(e),I(e="Aborted("+e+")"),v=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw u(t),t}function z(e){return e.startsWith("data:application/octet-stream;base64,")}function B(e){return e.startsWith("file://")}function H(e){try{if(e==D&&y)return new Uint8Array(y);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(e){T(e)}}function L(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function G(e){for(;e.length>0;)e.shift()(s)}function U(e){try{return g.grow(e-w.byteLength+65535>>>16),N(g.buffer),1}catch(e){}}z(D="tfjs-backend-wasm.wasm")||(R=D,D=s.locateFile?s.locateFile(R,h):h+R);var j=[null,[],[]];function q(e,t){var n=j[e];0===t||10===t?((1===e?k:I)(F(n,0)),n.length=0):n.push(t)}function V(e){return s["_"+e]}var $={abort:function(){T("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){S.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n=S.length,a=4294901760;if((e>>>=0)>a)return!1;for(var r=1;r<=4;r*=2){var u=n*(1+.2/r);if(u=Math.min(u,e+100663296),U(Math.min(a,(t=Math.max(e,u))+(65536-t%65536)%65536)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,a,r){return 70},fd_write:function(e,t,n,a){for(var r=0,u=0;u<n;u++){var i=A[t>>>2],s=A[t+4>>>2];t+=8;for(var o=0;o<s;o++)q(e,S[i+o>>>0]);r+=s}return A[a>>>2]=r,0}};!function(){var e={env:$,wasi_snapshot_preview1:$};function t(e,t){var n,a=e.exports;s.asm=a,N((g=s.asm.memory).buffer),s.asm.__indirect_function_table,n=s.asm.__wasm_call_ctors,P.unshift(n),function(){if(W--,s.monitorRunDependencies&&s.monitorRunDependencies(W),0==W&&O){var e=O;O=null,e()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!y&&(c||m)){if("function"==typeof fetch&&!B(D))return fetch(D,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+D+"'";return e.arrayBuffer()})).catch((function(){return H(D)}));if(d)return new Promise((function(e,t){d(D,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return H(D)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){I("failed to asynchronously prepare wasm: "+e),T(e)}))}if(W++,s.monitorRunDependencies&&s.monitorRunDependencies(W),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(e){I("Module.instantiateWasm callback failed with error: "+e),u(e)}(y||"function"!=typeof WebAssembly.instantiateStreaming||z(D)||B(D)||f||"function"!=typeof fetch?a(n):fetch(D,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return I("wasm streaming compile failed: "+e),I("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(u)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var K,X,Q,J=s.stackSave=function(){return(J=s.stackSave=s.asm.stackSave).apply(null,arguments)},Z=s.stackRestore=function(){return(Z=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Y=s.stackAlloc=function(){return(Y=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};function ee(e){function t(){K||(K=!0,s.calledRun=!0,v||(G(P),r(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)e=s.postRun.shift(),C.unshift(e);var e;G(C)}()))}W>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)e=s.preRun.shift(),E.unshift(e);var e;G(E)}(),W>0||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t()))}if(s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=function(e,t,n,a){var r=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&r&&!a?V(e):function(){return function(e,t,n,a){var r={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,a){if(!(a>0))return 0;for(var r=(n>>>=0)+a-1,u=0;u<e.length;++u){var i=e.charCodeAt(u);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++u)),i<=127){if(n>=r)break;t[n++>>>0]=i}else if(i<=2047){if(n+1>=r)break;t[n++>>>0]=192|i>>6,t[n++>>>0]=128|63&i}else if(i<=65535){if(n+2>=r)break;t[n++>>>0]=224|i>>12,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}}t[n>>>0]=0}(e,S,t,n)}(e,t=Y(n),n)}return t},array:e=>{var t=Y(e.length);return function(e,t){M.set(e,t>>>0)}(e,t),t}},u=V(e),i=[],s=0;if(a)for(var o=0;o<a.length;o++){var d=r[n[o]];d?(0===s&&(s=J()),i[o]=d(a[o])):i[o]=a[o]}return function(e){return 0!==s&&Z(s),function(e){return"string"===t?(n=e,(n>>>=0)?F(S,n,void 0):""):"boolean"===t?Boolean(e):e;var n}(e)}(u.apply(null,i))}(e,t,n,arguments)}},O=function e(){K||ee(),K||(O=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(ee(),i&&(X={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!i.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!i.unhandledRejection.indexOf(e)>-1}))}),void 0!==e)Q=e;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");Q=WasmBackendModuleThreadedSimd}if(X){var te=Q._dispose;Q._dispose=function(){te(),X.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),X.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});e.exports=r}(ar);var rr=ar.exports,ur=Za(rr);const ir=tr||nr,sr=ur||i({__proto__:null,default:ur},[rr]);class or extends t.KernelBackend{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(br),_r=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new t.DataStorage(this,t.engine())}write(e,t,n){const a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const n=t.util.now();return e(),{kernelMs:t.util.now()-n}}move(e,n,a,r,u){const i=this.dataIdNextNumber++;if("string"===r){const t=n;return void this.dataIdMap.set(e,{id:i,stringBytes:t,shape:a,dtype:r,memoryOffset:null,refCount:u})}const s=t.util.sizeFromShape(a),o=s*t.util.bytesPerElement(r),d=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:i,memoryOffset:d,shape:a,dtype:r,refCount:u}),this.wasm.tfjs.registerTensor(i,s,d),null!=n&&this.wasm.HEAPU8.set(new Uint8Array(n.buffer,n.byteOffset,o),d)}async read(e){return this.readSync(e)}readSync(e,n,a){const{memoryOffset:r,dtype:u,shape:i,stringBytes:s}=this.dataIdMap.get(e);if("string"===u)return null!=n&&0!==n||!(null==a||a>=s.length)?s.slice(n,a):s;n=n||0,a=a||t.util.sizeFromShape(i);const o=t.util.bytesPerElement(u);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+n*o,r+a*o).buffer,u)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){const t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,n,a,r){let u;if(null==a)u=this.write(null!=r?r:null,e,n);else{const r=this.dataIdNextNumber++;u={id:r},this.dataIdMap.set(u,{id:r,memoryOffset:a,shape:e,dtype:n,refCount:1});const i=t.util.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,i,a)}return{dataId:u,shape:e,dtype:n}}typedArrayFromHeap({shape:e,dtype:n,dataId:a}){const r=this.wasm.HEAPU8.buffer,{memoryOffset:u}=this.dataIdMap.get(a),i=t.util.sizeFromShape(e);switch(n){case"float32":return new Float32Array(r,u,i);case"int32":return new Int32Array(r,u,i);case"bool":return new Uint8Array(r,u,i);default:throw new Error(`Unknown dtype ${n}`)}}}function dr(e,t,n){if(null!=pr)return pr;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),null!=mr&&null!=mr[a]?mr[a]:n+a}const lr=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let pr=null,cr=null,mr={},fr=!1,hr=!1,br=-1,_r=-1;t.registerBackend("wasm",(async()=>{const{wasm:e}=await async function(){const[e,n]=await Promise.all([t.env().getAsync("WASM_HAS_SIMD_SUPPORT"),t.env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((a,r)=>{const u={};var i;u.locateFile=(t,a)=>{if(t.endsWith(".worker.js")){const e='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return t.endsWith(".wasm")?dr(e,n,null!=cr?cr:a):a+t},hr&&(u.instantiateWasm=(i=dr(e,n,null!=cr?cr:""),(e,n)=>(t.util.fetch(i,{credentials:"same-origin"}).then((t=>{t.ok||e.env.a(`failed to load wasm binary file at '${i}'`),t.arrayBuffer().then((t=>{WebAssembly.instantiate(t,e).then((e=>{n(e.instance,e.module)}))}))})),{})));let s,o=!1;u.onAbort=()=>{o||fr||(fr=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},n&&e&&null==pr?(u.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+ir.toString()],{type:"text/javascript"}),s=ir(u)):s=sr(u),s.then((e=>{o=!0,fr=!1,e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},a({wasm:e})})).catch(r)}))}();return new or(e)}),2),e.BackendWasm=or,e.getThreadsCount=function(){if(-1===_r)throw new Error("WASM backend not initialized.");return _r},e.setThreadsCount=function(e){br=e},e.setWasmPath=function(e,n=!1){if(t.deprecationWarn("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),fr)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");pr=e,hr=n},e.setWasmPaths=function(e,t=!1){if(fr)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)cr=e;else{mr=e;const t=lr.filter((e=>null==mr[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}hr=t},e.version_wasm="4.20.0"}));
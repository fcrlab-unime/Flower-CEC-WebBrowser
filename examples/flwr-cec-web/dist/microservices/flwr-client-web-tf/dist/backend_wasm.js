/*! For license information please see backend_wasm.js.LICENSE.txt */
import"./flags_wasm";import{DataStorage,deprecationWarn,engine,env,KernelBackend,util}from"@tensorflow/tfjs-core";import*as wasmFactoryThreadedSimd_import from"../wasm-out/tfjs-backend-wasm-threaded-simd.js";import{wasmWorkerContents}from"../wasm-out/tfjs-backend-wasm-threaded-simd.worker.js";import*as wasmFactory_import from"../wasm-out/tfjs-backend-wasm.js";const wasmFactoryThreadedSimd=wasmFactoryThreadedSimd_import.default||wasmFactoryThreadedSimd_import,wasmFactory=wasmFactory_import.default||wasmFactory_import;export class BackendWasm extends KernelBackend{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(threadsCount),actualThreadsCount=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new DataStorage(this,engine())}write(t,e,a){const s={id:this.dataIdNextNumber++};return this.move(s,t,e,a,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){const e=util.now();return t(),{kernelMs:util.now()-e}}move(t,e,a,s,r){const n=this.dataIdNextNumber++;if("string"===s){const i=e;return void this.dataIdMap.set(t,{id:n,stringBytes:i,shape:a,dtype:s,memoryOffset:null,refCount:r})}const i=util.sizeFromShape(a),o=i*util.bytesPerElement(s),d=this.wasm._malloc(o)>>>0;this.dataIdMap.set(t,{id:n,memoryOffset:d,shape:a,dtype:s,refCount:r}),this.wasm.tfjs.registerTensor(n,i,d),null!=e&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,o),d)}async read(t){return this.readSync(t)}readSync(t,e,a){const{memoryOffset:s,dtype:r,shape:n,stringBytes:i}=this.dataIdMap.get(t);if("string"===r)return null!=e&&0!==e||!(null==a||a>=i.length)?i.slice(e,a):i;e=e||0,a=a||util.sizeFromShape(n);const o=util.bytesPerElement(r);return typedArrayFromBuffer(this.wasm.HEAPU8.slice(s+e*o,s+a*o).buffer,r)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){const a=this.dataIdMap.get(t);if(a.refCount--,!e&&a.refCount>0)return!1;this.wasm._free(a.memoryOffset),this.wasm.tfjs.disposeData(a.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){const e=this.dataIdMap.get(t);null!=e&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,a,s){let r;if(null==a)r=this.write(null!=s?s:null,t,e);else{const s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:a,shape:t,dtype:e,refCount:1});const n=util.sizeFromShape(t);this.wasm.tfjs.registerTensor(s,n,a)}return{dataId:r,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:a}){const s=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(a),n=util.sizeFromShape(t);switch(e){case"float32":return new Float32Array(s,r,n);case"int32":return new Int32Array(s,r,n);case"bool":return new Uint8Array(s,r,n);default:throw new Error(`Unknown dtype ${e}`)}}}function createInstantiateWasmFunc(t){return(e,a)=>(util.fetch(t,{credentials:"same-origin"}).then((s=>{s.ok||e.env.a(`failed to load wasm binary file at '${t}'`),s.arrayBuffer().then((t=>{WebAssembly.instantiate(t,e).then((t=>{a(t.instance,t.module)}))}))})),{})}function getPathToWasmBinary(t,e,a){if(null!=wasmPath)return wasmPath;let s="tfjs-backend-wasm.wasm";return t&&e?s="tfjs-backend-wasm-threaded-simd.wasm":t&&(s="tfjs-backend-wasm-simd.wasm"),null!=wasmFileMap&&null!=wasmFileMap[s]?wasmFileMap[s]:a+s}export async function init(){const[t,e]=await Promise.all([env().getAsync("WASM_HAS_SIMD_SUPPORT"),env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((a,s)=>{const r={locateFile:(a,s)=>{if(a.endsWith(".worker.js")){const t=wasmWorkerContents.replace(/\n/g,"\\n"),e=new Blob([t],{type:"application/javascript"});return URL.createObjectURL(e)}return a.endsWith(".wasm")?getPathToWasmBinary(t,e,null!=wasmPathPrefix?wasmPathPrefix:s):s+a}};customFetch&&(r.instantiateWasm=createInstantiateWasmFunc(getPathToWasmBinary(t,e,null!=wasmPathPrefix?wasmPathPrefix:"")));let n,i=!1;r.onAbort=()=>{i||initAborted||(initAborted=!0,s({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},e&&t&&null==wasmPath?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+wasmFactoryThreadedSimd.toString()],{type:"text/javascript"}),n=wasmFactoryThreadedSimd(r)):n=wasmFactory(r),n.then((t=>{i=!0,initAborted=!1,t.tfjs={init:t.cwrap("init",null,[]),initWithThreadsCount:t.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:t.cwrap("get_threads_count","number",[]),registerTensor:t.cwrap("register_tensor",null,["number","number","number"]),disposeData:t.cwrap("dispose_data",null,["number"]),dispose:t.cwrap("dispose",null,[])},a({wasm:t})})).catch(s)}))}function typedArrayFromBuffer(t,e){switch(e){case"float32":return new Float32Array(t);case"int32":return new Int32Array(t);case"bool":return new Uint8Array(t);default:throw new Error(`Unknown dtype ${e}`)}}const wasmBinaryNames=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let wasmPath=null,wasmPathPrefix=null,wasmFileMap={},initAborted=!1,customFetch=!1;export function setWasmPath(t,e=!1){if(deprecationWarn("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");wasmPath=t,customFetch=e}export function setWasmPaths(t,e=!1){if(initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof t)wasmPathPrefix=t;else{wasmFileMap=t;const e=wasmBinaryNames.filter((t=>null==wasmFileMap[t]));if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}customFetch=e}export function resetWasmPath(){wasmPath=null,wasmPathPrefix=null,wasmFileMap={},customFetch=!1,initAborted=!1}let threadsCount=-1,actualThreadsCount=-1;export function setThreadsCount(t){threadsCount=t}export function getThreadsCount(){if(-1===actualThreadsCount)throw new Error("WASM backend not initialized.");return actualThreadsCount}
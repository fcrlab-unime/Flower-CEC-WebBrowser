/*! For license information please see tf-backend-wasm.fesm.js.LICENSE.txt */
import{_FusedMatMul,broadcast_util,util,Abs,Acos,Acosh,backend_util,Add,AddN,Identity,tensor,Transpose,All,Any,ArgMax,ArgMin,Asin,Asinh,Atan,Atan2,Atanh,AvgPool,AvgPool3D,AvgPool3DGrad,AvgPoolGrad,Reshape,BatchMatMul,slice_util,buffer,TensorBuffer,Slice,BatchToSpaceND,Bincount,BitwiseAnd,BroadcastArgs,Cast,Ceil,ClipByValue,Concat,Conv2D,Conv2DBackpropInput,Conv3D,Conv3DBackpropFilterV2,Conv3DBackpropInputV2,Cos,Cosh,CropAndResize,Cumprod,Cumsum,DenseBincount,DepthToSpace,DepthwiseConv2dNative,Diag,Dilation2D,Dilation2DBackpropFilter,Dilation2DBackpropInput,Elu,EluGrad,Equal,Erf,Exp,ExpandDims,Expm1,Fill,FlipLeftRight,Floor,FloorDiv,FusedBatchNorm,FusedConv2D,FusedDepthwiseConv2D,GatherNd,gather_util,GatherV2,Greater,GreaterEqual,IsFinite,IsInf,IsNan,LeakyRelu,Less,LessEqual,LinSpace,Log,Log1p,LogicalAnd,LogicalNot,LogicalOr,LogicalXor,LRN,LRNGrad,Max,Maximum,MaxPool,MaxPool3D,MaxPool3DGrad,MaxPoolGrad,MaxPoolWithArgmax,Mean,Min,Minimum,MirrorPad,Softmax,Multinomial,Mod,Multiply,Neg,NonMaxSuppressionV3,NonMaxSuppressionV4,NonMaxSuppressionV5,NotEqual,OneHot,OnesLike,Pack,PadV2,Pow,Prelu,Prod,Range,RealDiv,Reciprocal,Relu,Relu6,ResizeBilinear,ResizeBilinearGrad,ResizeNearestNeighbor,ResizeNearestNeighborGrad,Reverse,RotateWithOffset,Round,Rsqrt,ScatterNd,scatter_util,SearchSorted,Select,Selu,Sigmoid,Sign,Sin,Sinh,Softplus,SpaceToBatchND,SparseFillEmptyRows,SparseReshape,SparseSegmentMean,SparseSegmentSum,SparseToDense,SplitV,Sqrt,Square,SquaredDifference,Step,StridedSlice,StringNGrams,StringSplit,StringToHashBucketFast,Sub,Sum,Tan,Tanh,TensorScatterUpdate,Tile,TopK,Transform,Unique,Unpack,ZerosLike,registerKernel,env,KernelBackend,DataStorage,engine,deprecationWarn,registerBackend}from"@tensorflow/tfjs-core";import require$$0 from"fs";import require$$1 from"path";import require$$3 from"perf_hooks";import require$$4 from"os";function _mergeNamespaces(e,t){return t.forEach((function(t){t&&"string"!=typeof t&&!Array.isArray(t)&&Object.keys(t).forEach((function(n){if("default"!==n&&!(n in e)){var a=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,a.get?a:{enumerable:!0,get:function(){return t[n]}})}}))})),e}var CppDType,FusableActivation;let wasmFusedMatMul;function setup$1a(e){wasmFusedMatMul=e.wasm.cwrap(_FusedMatMul,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function fusedBatchMatMul(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:u}=t;if("float32"!==r.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:o,transposeB:p,activation:d,leakyreluAlpha:l}=a,c=n.dataIdMap.get(r.dataId).id,m=n.dataIdMap.get(s.dataId).id;let f=0;if(null!=i){const e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}const h=null==u?0:n.dataIdMap.get(u.dataId).id,g=FusableActivation[d];if(null==g)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);const b=o?r.shape[2]:r.shape[1],y=p?s.shape[1]:s.shape[2],_=broadcast_util.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),w=n.makeOutput([..._,b,y],r.dtype),k=n.dataIdMap.get(w.dataId).id,I=new Uint8Array(new Int32Array(r.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return wasmFusedMatMul(c,I,r.shape.length,m,S,s.shape.length,o,p,g,f,h,l||0,k),w}!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(CppDType||(CppDType={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(FusableActivation||(FusableActivation={}));const _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"wasm",setupFunc:setup$1a,kernelFunc:fusedBatchMatMul};function createUnaryKernelConfig(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){const{backend:a,inputs:{x:r}}=e,s=a.dataIdMap.get(r.dataId).id,i=a.makeOutput(r.shape,t||r.dtype),u=a.dataIdMap.get(i.dataId).id;return 0===util.sizeFromShape(i.shape)||n(s,CppDType[r.dtype],u),i}}}const absConfig=createUnaryKernelConfig(Abs),acosConfig=createUnaryKernelConfig(Acos),acoshConfig=createUnaryKernelConfig(Acosh);function createBinaryKernelConfig(e,t,n){let a;return{kernelName:e,backendName:"wasm",setupFunc:function(t){a=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:r}=e,{a:s,b:i}=r,u=t.dataIdMap.get(s.dataId).id,o=t.dataIdMap.get(i.dataId).id,p=null!=n?n:s.dtype,d=backend_util.assertAndGetBroadcastShape(s.shape,i.shape),l=t.makeOutput(d,p);if(0===util.sizeFromShape(d))return l;const c=new Uint8Array(new Int32Array(s.shape).buffer),m=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(l.dataId).id;return a(u,c,s.shape.length,o,m,i.shape.length,CppDType[s.dtype],f),l}}}const addConfig=createBinaryKernelConfig(Add);let wasmFunc$6;function setupFunc$1(e){wasmFunc$6=e.wasm.cwrap(AddN,null,["array","number","number","number"])}function addn(e){const{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(0===util.sizeFromShape(a.shape))return a;const r=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return wasmFunc$6(s,r.length,CppDType[a.dtype],i),a}const addNConfig={kernelName:AddN,backendName:"wasm",setupFunc:setupFunc$1,kernelFunc:addn};function identity(e){const{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return tensor(n.readSync(t.dataId),t.shape,t.dtype);const a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}const identityConfig={kernelName:Identity,backendName:"wasm",kernelFunc:identity};let wasmTranspose;function setup$19(e){wasmTranspose=e.wasm.cwrap(Transpose,null,["number","array","number","number","number","array","number"])}function transpose(e){const{inputs:t,backend:n,attrs:a}=e,[r,s]=removeOneSizeDims(t.x.shape,a.perm);let i=!0;for(let e=0;e<s.length;e++)s[e]!==e&&(i=!1);const u=computeOutShape(t.x.shape,a.perm),o={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){const e=identity({inputs:t,backend:n});return e.shape=u,e}const p=n.makeOutput(u,o.dtype),d=n.dataIdMap.get(o.dataId).id,l=n.dataIdMap.get(p.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),m=new Uint8Array(new Int32Array(o.shape).buffer);return wasmTranspose(d,m,o.shape.length,CppDType[o.dtype],l,c,s.length),p}function computeOutShape(e,t){const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function removeOneSizeDims(e,t){const n=[],a=[];for(let r=0;r<e.length;++r)1!==e[r]&&n.push(e[r]),1!==e[t[r]]&&a.push(t[r]);for(let e=0;e<a.length;++e){let t=-1;for(let n=0;n<a.length;++n)a[n]>=e&&(-1===t||a[t]>a[n])&&(t=n);a[t]=e}return[n,a]}const transposeConfig={kernelName:Transpose,backendName:"wasm",kernelFunc:transpose,setupFunc:setup$19};function permuteAxesAndTranspose(e,t,n){const a=e.shape,r=e.shape.length,s=util.parseAxisParam(t,a);let i=s;const u=backend_util.getAxesPermutation(i,r);let o=null,p=!1;if(null!=u){const t=new Array(r);for(let e=0;e<t.length;e++)t[e]=a[u[e]];i=backend_util.getInnerMostAxes(i.length,r),o=transpose({inputs:{x:e},attrs:{perm:u},backend:n});const s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(o.dataId).id!==s&&(p=!0)}return{transposed:o,originalAxes:s,axes:i,inputWasTransposed:p}}let wasmAll;function setup$18(e){wasmAll=e.wasm.cwrap(All,null,["number, number, number"])}function all(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n;let u=t.dataIdMap.get(i.dataId).id,o=i;const{transposed:p,axes:d,originalAxes:l,inputWasTransposed:c}=permuteAxesAndTranspose(i,r,t);c&&(o=p,u=t.dataIdMap.get(p.dataId).id);const m=o.shape.length;backend_util.assertAxesAreInnerMostDims("all",d,m);const[f,h]=backend_util.computeOutAndReduceShapes(o.shape,d),g=util.sizeFromShape(h),b=t.makeOutput(f,i.dtype);if(0!==util.sizeFromShape(o.shape)){const e=t.dataIdMap.get(b.dataId).id;wasmAll(u,g,e)}if(c&&t.disposeData(p.dataId),s){const e=backend_util.expandShapeToKeepDim(b.shape,l);b.shape=e}return b}const allConfig={kernelName:All,backendName:"wasm",setupFunc:setup$18,kernelFunc:all};let wasmAny;function setup$17(e){wasmAny=e.wasm.cwrap(Any,null,["number, number, number"])}function any(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n;let u=t.dataIdMap.get(i.dataId).id,o=i;const{transposed:p,axes:d,originalAxes:l,inputWasTransposed:c}=permuteAxesAndTranspose(i,r,t);c&&(o=p,u=t.dataIdMap.get(p.dataId).id);const m=o.shape.length;backend_util.assertAxesAreInnerMostDims("any",d,m);const[f,h]=backend_util.computeOutAndReduceShapes(o.shape,d),g=util.sizeFromShape(h),b=t.makeOutput(f,i.dtype);if(0!==util.sizeFromShape(o.shape)){const e=t.dataIdMap.get(b.dataId).id;wasmAny(u,g,e)}if(c&&t.disposeData(p.dataId),s){const e=backend_util.expandShapeToKeepDim(b.shape,l);b.shape=e}return b}const anyConfig={kernelName:Any,backendName:"wasm",setupFunc:setup$17,kernelFunc:any};function createArgMinMaxKernelConfig(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){const{backend:n,inputs:a,attrs:r}=e,{axis:s}=r,{x:i}=a,u=n.dataIdMap.get(i.dataId).id;let o=u,p=i;const{transposed:d,axes:l,inputWasTransposed:c}=permuteAxesAndTranspose(i,s,n);if(c){const e=n.dataIdMap.get(d.dataId).id;e!==u&&(p=d,o=e)}const m=p.shape.slice(0,-1),f=n.makeOutput(m,"int32"),h=n.dataIdMap.get(f.dataId).id,g=util.sizeFromShape(f.shape),b=p.shape[l[0]];return t(o,CppDType[p.dtype],g,b,h),c&&n.disposeData(d.dataId),f}}}const argMaxConfig=createArgMinMaxKernelConfig(ArgMax),argMinConfig=createArgMinMaxKernelConfig(ArgMin),asinConfig=createUnaryKernelConfig(Asin),asinhConfig=createUnaryKernelConfig(Asinh),atanConfig=createUnaryKernelConfig(Atan),atan2Config=createBinaryKernelConfig(Atan2),atanhConfig=createUnaryKernelConfig(Atanh);let wasmAvgPool;function setup$16(e){wasmAvgPool=e.wasm.cwrap(AvgPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function avgPool(e){const{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:u,pad:o,dimRoundingMode:p}=n,d=backend_util.computePool2DInfo(r.shape,i,u,1,o,p),l=d.filterHeight,c=d.filterWidth,m=d.padInfo.top,f=d.padInfo.right,h=d.padInfo.bottom,g=d.padInfo.left,b=d.strideHeight,y=d.strideWidth,_=d.inChannels;if("channelsLast"!==d.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);if(1!==d.dilationWidth||1!==d.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${d.dilationHeight}, ${d.dilationWidth}].`);const w=a.makeOutput(d.outShape,"float32"),k=a.dataIdMap.get(w.dataId).id;return wasmAvgPool(s,r.shape[0],r.shape[1],r.shape[2],l,c,m,f,h,g,b,y,_,k),w}const avgPoolConfig={kernelName:AvgPool,backendName:"wasm",setupFunc:setup$16,kernelFunc:avgPool};let wasmAvgPool3D;function setup$15(e){wasmAvgPool3D=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function avgPool3D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:u,dimRoundingMode:o,dataFormat:p}=a,d=backend_util.computePool3DInfo(r.shape,s,i,1,u,o,p),l=n.makeOutput(d.outShape,r.dtype);return wasmAvgPool3D(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),l}const avgPool3DConfig={kernelName:AvgPool3D,backendName:"wasm",setupFunc:setup$15,kernelFunc:avgPool3D};let wasmAvgPool3DGrad;function setup$14(e){wasmAvgPool3DGrad=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function avgPool3DGrad(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:u,pad:o,dimRoundingMode:p}=a,d=backend_util.computePool3DInfo(s.shape,i,u,1,o,p),l=n.makeOutput(s.shape,s.dtype);return wasmAvgPool3DGrad(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left,d.filterDepth,d.filterHeight,d.filterWidth),l}const avgPool3DGradConfig={kernelName:AvgPool3DGrad,backendName:"wasm",setupFunc:setup$14,kernelFunc:avgPool3DGrad};let wasmAvgPoolGrad;function setup$13(e){wasmAvgPoolGrad=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function avgPoolGrad(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:u,pad:o}=a,p=backend_util.computePool2DInfo(s.shape,i,u,1,o),d=n.makeOutput(s.shape,s.dtype);return wasmAvgPoolGrad(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left,p.filterHeight,p.filterWidth),d}const avgPoolGradConfig={kernelName:AvgPoolGrad,backendName:"wasm",setupFunc:setup$13,kernelFunc:avgPoolGrad};function reshape(e){const{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=util.sizeFromShape(a.shape),i=util.inferFromImplicitShape(r,s);return util.assert(s===util.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}const reshapeConfig={kernelName:Reshape,backendName:"wasm",kernelFunc:reshape};let wasmBatchMatMul;function setup$12(e){wasmBatchMatMul=e.wasm.cwrap(BatchMatMul,null,["number","array","number","number","array","number","number","number","number"])}function batchMatMul(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:u}=a;if("float32"!==r.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const o=r.shape.length,p=s.shape.length,d=i?r.shape[o-2]:r.shape[o-1],l=u?s.shape[p-1]:s.shape[p-2],c=i?r.shape[o-1]:r.shape[o-2],m=u?s.shape[p-2]:s.shape[p-1],f=r.shape.slice(0,-2),h=s.shape.slice(0,-2),g=util.sizeFromShape(f),b=util.sizeFromShape(h),y=broadcast_util.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,m]);util.assert(d===l,(()=>`Error in matMul: inner shapes (${d}) and (${l}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${u} must match.`));const _=u?[b,m,l]:[b,l,m],w=reshape({inputs:{x:r},backend:n,attrs:{shape:i?[g,d,c]:[g,c,d]}}),k=reshape({inputs:{x:s},backend:n,attrs:{shape:_}}),I=n.dataIdMap.get(w.dataId).id,S=n.dataIdMap.get(k.dataId).id,M=i?w.shape[2]:w.shape[1],C=u?k.shape[1]:k.shape[2],D=Math.max(g,b),A=n.makeOutput([D,M,C],w.dtype),v=n.dataIdMap.get(A.dataId).id,x=new Uint8Array(new Int32Array(w.shape).buffer),F=new Uint8Array(new Int32Array(k.shape).buffer);return wasmBatchMatMul(I,x,w.shape.length,S,F,k.shape.length,i,u,v),n.disposeData(w.dataId),n.disposeData(k.dataId),A.shape=y,A}const batchMatMulConfig={kernelName:BatchMatMul,backendName:"wasm",setupFunc:setup$12,kernelFunc:batchMatMul};function concatImpl(e,t,n,a){const r=util.getArrayFromDType(n,util.sizeFromShape(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=util.sizeFromShape(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const s="string"===n?backend_util.fromUint8ToStringArray(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const u=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[u+t]=s[i++]}a+=e.shape[1]}))}return r}function rangeImpl(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return util.makeZerosTypedArray(0,a);const r=Math.abs(Math.ceil((t-e)/n)),s=util.makeZerosTypedArray(r,a);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}function sliceImpl(e,t,n,a,r){const s=slice_util.isSliceContinous(a,t,n),i=util.sizeFromShape(n),u=util.computeStrides(a);if(s){const n=slice_util.computeFlatOffset(t,u);return"string"===r?e.slice(n,n+i):e.subarray(n,n+i)}const o="string"===r?backend_util.fromUint8ToStringArray(e):e,p=buffer(a,r,o),d=buffer(n,r);for(let e=0;e<d.size;++e){const n=d.indexToLoc(e),a=n.map(((e,n)=>e+t[n]));d.set(p.get(...a),...n)}return"string"===r?backend_util.fromStringArrayToUint8(d.values):d.values}backend_util.RowPartitionType;class StringNGramsOp{constructor(e,t,n,a,r,s){this.separator=util.encodeString(e),this.nGramWidths=t,this.leftPad=util.encodeString(n),this.rightPad=util.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){const u=this.getPadWidth(s),o=Math.max(0,u-i),p=Math.max(0,u-(r-(i+1))),d=s-(o+p),l=t+(o>0?0:i-u);let c=0;c+=o*this.leftPad.length;for(let t=0;t<d;++t)c+=e[l+t].length;c+=p*this.rightPad.length,c+=(o+p+d-1)*this.separator.length,n[a+i]=new Uint8Array(c);const m=n[a+i];let f=0;const h=e=>e.forEach((e=>m[f++]=e));for(let e=0;e<o;++e)h(this.leftPad),h(this.separator);for(let t=0;t<d-1;++t)h(e[l+t]),h(this.separator);if(d>0){h(e[l+d-1]);for(let e=0;e<p;++e)h(this.separator),h(this.rightPad)}else{for(let e=0;e<p-1;++e)h(this.rightPad),h(this.separator);h(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const r=a-1,s=util.getArrayFromDType("int32",a);if(0===n||0===a){const e=new Array(n);for(let e=0;e<=r;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=r;++e){const n=t[e]-t[e-1];let a=0;this.nGramWidths.forEach((e=>{a+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===a&&(a=1),s[e]=s[e-1]+a}const i=new Array(s[r]);for(let n=0;n<r;++n){const a=t[n];let r=s[n];if(this.nGramWidths.forEach((s=>{const u=t[n+1]-t[n],o=this.getNumNGrams(u,s);this.createNGrams(e,a,i,r,o,s),r+=o})),this.preserveShort&&r===s[n]){const s=t[n+1]-t[n];if(0===s)continue;const u=s+2*this.padWidth,o=1;this.createNGrams(e,a,i,r,o,u)}}return[i,s]}}function stringNGramsImpl(e,t,n,a,r,s,i,u){return new StringNGramsOp(n,a,r,s,i,u).compute(e,t)}function split(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let s=e.indexOf(r);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||a.push(t),s=(e=e.subarray(s+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(r,s);n&&0===t.length||a.push(t),r=s+1}}function stringSplitImpl(e,t,n){const a=e.length,r=[];let s=0,i=0;const u=new Array(a);for(let o=0;o<a;++o){const a=r.length;split(e[o],t,n,r);const p=r.length-a;u[o]=p,s+=p,i=Math.max(i,p)}const o=util.getArrayFromDType("int32",2*s),p=new Array(s),d=[a,i];let l=0;for(let e=0;e<a;++e)for(let t=0;t<u[e];++t)o[2*l]=e,o[2*l+1]=t,p[l]=r[l],++l;return[o,p,d]}function stringToHashBucketFastImpl(e,t){const n=util.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=util.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}function uniqueImpl(e,t,n,a){const r=util.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<r;e++)s[0]*=n[e];s[1]=n[r];for(let e=r+1;e<n.length;e++)s[2]*=n[e];const i=new Map,u=new Int32Array(n[r]),o=new TensorBuffer(s,a,e),p=[],d=1===s[0]&&1===s[2];for(let t=0;t<n[r];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)e.push(o.get(n,t,a));n=e.join(",")}const a=i.get(n);if(null!=a)u[t]=a;else{const e=i.size;i.set(n,e),u[t]=e,p.push(t)}}const l=s.slice();l[1]=i.size;const c=new TensorBuffer(l,a);p.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)c.set(o.get(n,e,a),n,t,a)}));const m=n.slice();return m[r]=l[1],{outputValues:c.values,outputShape:m,indices:u}}function slice(e){const{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=slice_util.parseSliceParams(t,n,a),u=slice_util.isSliceContinous(t.shape,s,i),o=r.readSync(t.dataId),p=r.makeOutput(i,t.dtype),d=util.computeStrides(t.shape),l=r.dataIdMap.get(p.dataId);if(u){const e=slice_util.computeFlatOffset(s,d);return"string"===t.dtype?l.stringBytes=o.slice(e,e+util.sizeFromShape(i)):r.typedArrayFromHeap(p).set(o.subarray(e,e+util.sizeFromShape(i))),p}if("string"===t.dtype){const e=sliceImpl(o,s,i,t.shape,t.dtype);return l.stringBytes=e,p}const c=r.typedArrayFromHeap(p),m=t.shape.length;if(2===m)slice2d(o,d[0],c,s,i);else if(3===m)slice3d(o,d[0],d[1],c,s,i);else if(4===m)slice4d(o,d[0],d[1],d[2],c,s,i);else{const e=sliceImpl(o,s,i,t.shape,t.dtype);c.set(e)}return p}function slice2d(e,t,n,a,r){let s=0;const i=a[0],u=a[1],o=i+r[0];for(let a=i;a<o;a++){const i=a*t+u;n.set(e.subarray(i,i+r[1]),s),s+=r[1]}}function slice3d(e,t,n,a,r,s){let i=0;const u=r[0],o=r[1],p=r[2],d=u+s[0],l=o+s[1];for(let r=u;r<d;r++)for(let u=o;u<l;u++){const o=r*t+u*n+p;a.set(e.subarray(o,o+s[2]),i),i+=s[2]}}function slice4d(e,t,n,a,r,s,i){let u=0;const o=s[0],p=s[1],d=s[2],l=o+i[0],c=p+i[1],m=d+i[2],f=s[3];for(let s=o;s<l;s++)for(let o=p;o<c;o++)for(let p=d;p<m;p++){const d=s*t+o*n+p*a+f;r.set(e.subarray(d,d+i[3]),u),u+=i[3]}}const sliceConfig={kernelName:Slice,backendName:"wasm",kernelFunc:slice};function batchToSpaceND(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,u=s.reduce(((e,t)=>e*t)),o=backend_util.getReshaped(r.shape,s,u),p=backend_util.getPermuted(o.length,s.length),d=backend_util.getReshapedPermuted(r.shape,s,u),l=backend_util.getSliceBeginCoords(i,s.length),c=backend_util.getSliceSize(d,i,s.length),m=reshape({inputs:{x:r},backend:n,attrs:{shape:o}}),f=transpose({inputs:{x:m},backend:n,attrs:{perm:p}}),h=reshape({inputs:{x:f},backend:n,attrs:{shape:d}}),g=slice({inputs:{x:h},backend:n,attrs:{begin:l,size:c}});return n.disposeData(m.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),g}const batchToSpaceNDConfig={kernelName:BatchToSpaceND,backendName:"wasm",kernelFunc:batchToSpaceND};let wasmBincount;function setup$11(e){wasmBincount=e.wasm.cwrap(Bincount,null,["number","number","boolean","number","number","number"])}function bincount(e){const{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,u=0!==s.shape.reduce(((e,t)=>e*t),1),o=1===r.shape.length?[i]:[r.shape[0],i],p=t.makeOutput(o,s.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return wasmBincount(d(r),i,u,d(s),CppDType[s.dtype],d(p)),p}const bincountConfig={kernelName:Bincount,backendName:"wasm",setupFunc:setup$11,kernelFunc:bincount},bitwiseAndConfig=createBinaryKernelConfig(BitwiseAnd);function broadcastArgs(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),u=backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([u.length],"int32",void 0,new Int32Array(u))}const broadcastArgsConfig={kernelName:BroadcastArgs,backendName:"wasm",kernelFunc:broadcastArgs};function cast(e){const{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}const castConfig={kernelName:Cast,backendName:"wasm",kernelFunc:cast},ceilConfig=createUnaryKernelConfig(Ceil);let wasmClip;function setup$10(e){wasmClip=e.wasm.cwrap(ClipByValue,null,["number","number","number","number"])}function clip(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,u=n.dataIdMap.get(r.dataId).id,o=n.makeOutput(r.shape,r.dtype),p=n.dataIdMap.get(o.dataId).id;return wasmClip(u,s,i,p),o}const clipByValueConfig={kernelName:ClipByValue,backendName:"wasm",setupFunc:setup$10,kernelFunc:clip};function concat(e){const{inputs:t,backend:n}=e,a=util.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map((e=>e.shape));backend_util.assertParamsConsistent(r,a);let s=backend_util.computeOutShape(t.map((e=>e.shape)),a);const i=t.filter((e=>util.sizeFromShape(e.shape)>0));if(1===i.length)return identity({inputs:{x:i[0]},backend:n});const u=n.makeOutput(s,t[0].dtype);if(0===util.sizeFromShape(s))return u;if("string"===i[0].dtype){const e=i.map((e=>{const t=util.sizeFromShape(e.shape.slice(a));return reshape({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),r=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));s=backend_util.computeOutShape(e.map((e=>e.shape)),1);const o=1===e[0].shape[0],p=concatImpl(r,s,t[0].dtype,o),d=backend_util.computeOutShape(i.map((e=>e.shape)),a);return u.shape=d,n.dataIdMap.get(u.dataId).stringBytes=backend_util.fromStringArrayToUint8(p),e.forEach((e=>n.disposeData(e.dataId))),u}const o=util.sizeFromShape(i[0].shape.slice(0,a));let p=0;const d=i.map((e=>{const t=util.sizeFromShape(e.shape.slice(a));return p+=t,t})),l=i.map((e=>n.typedArrayFromHeap(e))),c=n.typedArrayFromHeap(u);for(let e=0;e<o;e++){let t=e*p;for(let n=0;n<l.length;n++){const a=d[n],r=e*a,s=l[n].subarray(r,r+a);c.set(s,t),t+=a}}return u}const concatConfig={kernelName:Concat,backendName:"wasm",kernelFunc:concat};let wasmConv2d;function setup$$(e){wasmConv2d=e.wasm.cwrap(Conv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv2d(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,u=a.dataIdMap.get(s.dataId).id,{strides:o,dilations:p,pad:d,dimRoundingMode:l,dataFormat:c}=n,m=backend_util.convertConv2DDataFormat(c),f=backend_util.computeConv2DInfo(r.shape,s.shape,o,p,d,l,!1,m),h=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,y=f.padInfo.right,_=f.padInfo.bottom,w=f.padInfo.left,k=f.dilationHeight,I=f.dilationWidth,S=f.strideHeight,M=f.strideWidth,C=f.inChannels,D=f.outChannels,A="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const v=a.makeOutput(f.outShape,"float32"),x=a.dataIdMap.get(v.dataId).id;return wasmConv2d(i,r.shape[0],r.shape[1],r.shape[2],u,h,g,b,y,_,w,A,k,I,S,M,C,D,x),v}const conv2DConfig={kernelName:Conv2D,backendName:"wasm",setupFunc:setup$$,kernelFunc:conv2d};let wasmConv2DBackpropInput;function setup$_(e){wasmConv2DBackpropInput=e.wasm.cwrap(Conv2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv2DBackpropInput(e){const{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:u,dataFormat:o,dimRoundingMode:p,inputShape:d}=a,l=backend_util.convertConv2DDataFormat(o),c=backend_util.computeConv2DInfo(d,s.shape,i,1,u,p,!1,l),{batchSize:m,filterHeight:f,filterWidth:h,inChannels:g,inHeight:b,inWidth:y,outChannels:_,outHeight:w,outWidth:k,strideHeight:I,strideWidth:S}=c,M=f-1-c.padInfo.top,C=h-1-c.padInfo.left,D="channelsLast"===c.dataFormat,A=util.computeStrides(c.inShape),v=util.computeStrides(r.shape),[x,F,N]=util.computeStrides(s.shape),R=A[0],P=D?A[1]:A[2],T=D?A[2]:1,B=D?1:A[1],E=v[0],W=D?v[1]:v[2],$=D?v[2]:1,O=D?1:v[1],z=t.makeOutput(c.inShape,"float32"),G=t.dataIdMap.get(z.dataId).id,L=t.dataIdMap.get(r.dataId).id,H=t.dataIdMap.get(s.dataId).id;return wasmConv2DBackpropInput(L,H,m,f,h,b,y,g,w,k,_,I,S,M,C,x,F,N,R,P,T,B,E,W,$,O,G),z}const conv2DBackpropInputConfig={kernelName:Conv2DBackpropInput,backendName:"wasm",setupFunc:setup$_,kernelFunc:conv2DBackpropInput};let wasmConv3D;function setup$Z(e){wasmConv3D=e.wasm.cwrap(Conv3D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv3D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:u,dilations:o}=a;if("float32"!==r.dtype)throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);const p=backend_util.computeConv3DInfo(r.shape,s.shape,i,o,u),d=n.makeOutput(p.outShape,r.dtype);return wasmConv3D(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inDepth,p.inHeight,p.inWidth,p.inChannels,p.outDepth,p.outHeight,p.outWidth,p.outChannels,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.filterDepth,p.filterHeight,p.filterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}const conv3DConfig={kernelName:Conv3D,backendName:"wasm",setupFunc:setup$Z,kernelFunc:conv3D};let wasmConv3DBackpropFilterV2;function setup$Y(e){wasmConv3DBackpropFilterV2=e.wasm.cwrap(Conv3DBackpropFilterV2,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv3DBackpropFilterV2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:u,filterShape:o}=a;if("float32"!==r.dtype)throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);const p=backend_util.computeConv3DInfo(r.shape,o,i,1,u),d=n.makeOutput(p.filterShape,s.dtype);return wasmConv3DBackpropFilterV2(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inDepth,p.inHeight,p.inWidth,p.inChannels,p.outDepth,p.outHeight,p.outWidth,p.outChannels,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.filterDepth,p.filterHeight,p.filterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}const conv3DBackpropFilterV2Config={kernelName:Conv3DBackpropFilterV2,backendName:"wasm",setupFunc:setup$Y,kernelFunc:conv3DBackpropFilterV2};let wasmConv3DBackpropInputV2;function setup$X(e){wasmConv3DBackpropInputV2=e.wasm.cwrap(Conv3DBackpropInputV2,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv3DBackpropInputV2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:u,inputShape:o}=a;if("float32"!==r.dtype)throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);const p=backend_util.computeConv3DInfo(o,s.shape,u,1,i),d=n.makeOutput(p.inShape,r.dtype);return wasmConv3DBackpropInputV2(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inDepth,p.inHeight,p.inWidth,p.inChannels,p.outDepth,p.outHeight,p.outWidth,p.outChannels,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.filterDepth,p.filterHeight,p.filterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}const conv3DBackpropInputV2Config={kernelName:Conv3DBackpropInputV2,backendName:"wasm",setupFunc:setup$X,kernelFunc:conv3DBackpropInputV2},cosConfig=createUnaryKernelConfig(Cos),coshConfig=createUnaryKernelConfig(Cosh);var InterpolationMethod;let wasmCropAndResize;function setup$W(e){wasmCropAndResize=e.wasm.cwrap(CropAndResize,null,["number","number","number","number","array","number","number","number","number","number"])}function cropAndResize(e){const{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:i}=a,{image:u,boxes:o,boxInd:p}=n,d=o.shape[0],[l,c]=i,m=[d,l,c,u.shape[3]];let f,h=t.dataIdMap.get(u.dataId);"float32"!==u.dtype&&(f=cast({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(f.dataId));const g=h.id,b=t.dataIdMap.get(o.dataId).id,y=t.dataIdMap.get(p.dataId).id,_=t.makeOutput(m,"float32"),w=t.dataIdMap.get(_.dataId).id,k=new Uint8Array(new Int32Array(u.shape).buffer);return wasmCropAndResize(g,b,y,d,k,l,c,InterpolationMethod[r],s,w),null!=f&&t.disposeData(f.dataId),_}!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(InterpolationMethod||(InterpolationMethod={}));const cropAndResizeConfig={kernelName:CropAndResize,backendName:"wasm",setupFunc:setup$W,kernelFunc:cropAndResize};let wasmCumprod;function setup$V(e){wasmCumprod=e.wasm.cwrap(Cumprod,null,["number","number","number","number","number","number"])}function cumprod(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:u}=a,o=r.shape.length;util.assert("float32"===r.dtype||"int32"===r.dtype,(()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`));const p=backend_util.getAxesPermutation([s],o);let d=r;null!==p&&(d=transpose({inputs:{x:r},attrs:{perm:p},backend:n}));const l=backend_util.getInnerMostAxes(1,o)[0];backend_util.assertAxesAreInnerMostDims("cumprod",[l],o);const c=n.makeOutput(d.shape,d.dtype),m=d.shape[l],f=n.dataIdMap.get(d.dataId).id,h=n.dataIdMap.get(c.dataId).id;wasmCumprod(f,i?1:0,u?1:0,m,h,CppDType[r.dtype]);let g=c;return null!==p&&(g=transpose({inputs:{x:c},attrs:{perm:backend_util.getUndoAxesPermutation(p)},backend:n}),n.disposeData(d.dataId),n.disposeData(c.dataId)),g}const cumprodConfig={kernelName:Cumprod,backendName:"wasm",setupFunc:setup$V,kernelFunc:cumprod};let wasmCumsum;function setup$U(e){wasmCumsum=e.wasm.cwrap(Cumsum,null,["number","number","number","number","number","number"])}function cumsum(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:u}=a,o=r.shape.length;util.assert("float32"===r.dtype||"int32"===r.dtype,(()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`));const p=backend_util.getAxesPermutation([s],o);let d=r;null!==p&&(d=transpose({inputs:{x:r},attrs:{perm:p},backend:n}));const l=backend_util.getInnerMostAxes(1,o)[0];backend_util.assertAxesAreInnerMostDims("cumsum",[l],o);const c=n.makeOutput(d.shape,d.dtype),m=d.shape[l],f=n.dataIdMap.get(d.dataId).id,h=n.dataIdMap.get(c.dataId).id;wasmCumsum(f,i?1:0,u?1:0,m,h,CppDType[r.dtype]);let g=c;return null!==p&&(g=transpose({inputs:{x:c},attrs:{perm:backend_util.getUndoAxesPermutation(p)},backend:n}),n.disposeData(d.dataId),n.disposeData(c.dataId)),g}const cumsumConfig={kernelName:Cumsum,backendName:"wasm",setupFunc:setup$U,kernelFunc:cumsum};let wasmDenseBincount;function setup$T(e){wasmDenseBincount=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function denseBincount(e){const{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:u}=a,o=0!==s.shape.reduce(((e,t)=>e*t),1),p=1===r.shape.length?[i]:[r.shape[0],i],d=t.makeOutput(p,s.dtype);function l(e){return t.dataIdMap.get(e.dataId).id}return wasmDenseBincount(l(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,o,l(s),CppDType[s.dtype],u,l(d)),d}const denseBincountConfig={kernelName:DenseBincount,backendName:"wasm",setupFunc:setup$T,kernelFunc:denseBincount};let wasmDepthToSpace;function setup$S(e){wasmDepthToSpace=e.wasm.cwrap(DepthToSpace,null,["number","number","number","array","number","array","array","number","number"])}function depthToSpace(e){const{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,u=r.shape[0],o=("NHWC"===i?r.shape[1]:r.shape[2])*s,p=("NHWC"===i?r.shape[2]:r.shape[3])*s,d=("NHWC"===i?r.shape[3]:r.shape[1])/(s*s),l="NHWC"===i?[u,o,p,d]:[u,d,o,p],c=t.makeOutput(l,"float32"),m=t.dataIdMap.get(r.dataId).id,f=new Uint8Array(new Int32Array(util.computeStrides(r.shape)).buffer),h=new Uint8Array(new Int32Array(l).buffer),g=new Uint8Array(new Int32Array(util.computeStrides(l)).buffer),b=t.dataIdMap.get(c.dataId).id;return wasmDepthToSpace(m,s,"NHWC"===i?1:0,f,r.shape.length-1,h,g,l.length,b),c}const depthToSpaceConfig={kernelName:DepthToSpace,backendName:"wasm",setupFunc:setup$S,kernelFunc:depthToSpace};let wasmDepthwiseConv2d;function setup$R(e){wasmDepthwiseConv2d=e.wasm.cwrap(DepthwiseConv2dNative,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function depthwiseConv2d(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,u=a.dataIdMap.get(s.dataId).id,{strides:o,dilations:p,pad:d,dimRoundingMode:l}=n,c=null==p?[1,1]:p,m=backend_util.computeConv2DInfo(r.shape,s.shape,o,c,d,l,!0),f=m.filterHeight,h=m.filterWidth,g=m.padInfo.top,b=m.padInfo.right,y=m.padInfo.bottom,_=m.padInfo.left,w=m.dilationHeight,k=m.dilationWidth,I=m.strideHeight,S=m.strideWidth,M=m.inChannels,C=m.outChannels,D="SAME"===m.padInfo.type?1:0;if("channelsLast"!==m.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);const A=a.makeOutput(m.outShape,"float32"),v=a.dataIdMap.get(A.dataId).id;return wasmDepthwiseConv2d(i,r.shape[0],r.shape[1],r.shape[2],u,f,h,g,b,y,_,D,w,k,I,S,M,C,v),A}const depthwiseConv2dNativeConfig={kernelName:DepthwiseConv2dNative,backendName:"wasm",setupFunc:setup$R,kernelFunc:depthwiseConv2d};let wasmDiag;function setup$Q(e){wasmDiag=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function diag(e){const{inputs:t,backend:n}=e,{x:a}=t,r=util.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return wasmDiag(n.dataIdMap.get(a.dataId).id,CppDType[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}const diagConfig={kernelName:Diag,backendName:"wasm",setupFunc:setup$Q,kernelFunc:diag};let wasmDilation2D;function setup$P(e){wasmDilation2D=e.wasm.cwrap(Dilation2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dilation2D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:u,dilations:o}=a;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);const p=backend_util.computeDilation2DInfo(r.shape,s.shape,i,u,"NHWC",o),d=n.makeOutput(p.outShape,r.dtype);return wasmDilation2D(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,CppDType[r.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}const dilation2DConfig={kernelName:Dilation2D,backendName:"wasm",setupFunc:setup$P,kernelFunc:dilation2D};let wasmDilation2DBackpropFilter;function setup$O(e){wasmDilation2DBackpropFilter=e.wasm.cwrap(Dilation2DBackpropFilter,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dilation2DBackpropFilter(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:u,pad:o,dilations:p}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);const d=backend_util.computeDilation2DInfo(r.shape,s.shape,u,o,"NHWC",p),l=n.makeOutput(s.shape,s.dtype);return wasmDilation2DBackpropFilter(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(l.dataId).id,CppDType[r.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),l}const dilation2DBackpropFilterConfig={kernelName:Dilation2DBackpropFilter,backendName:"wasm",setupFunc:setup$O,kernelFunc:dilation2DBackpropFilter};let wasmDilation2DBackpropInput;function setup$N(e){wasmDilation2DBackpropInput=e.wasm.cwrap(Dilation2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dilation2DBackpropInput(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:u,pad:o,dilations:p}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);const d=backend_util.computeDilation2DInfo(r.shape,s.shape,u,o,"NHWC",p),l=n.makeOutput(r.shape,r.dtype);return wasmDilation2DBackpropInput(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(l.dataId).id,CppDType[r.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),l}const dilation2DBackpropInputConfig={kernelName:Dilation2DBackpropInput,backendName:"wasm",setupFunc:setup$N,kernelFunc:dilation2DBackpropInput},eluConfig=createUnaryKernelConfig(Elu);let wasmEluGrad;function setup$M(e){wasmEluGrad=e.wasm.cwrap(EluGrad,null,["number","number","number"])}function eluGrad(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return wasmEluGrad(i(r),i(a),i(s)),s}const eluGradConfig={kernelName:EluGrad,backendName:"wasm",setupFunc:setup$M,kernelFunc:eluGrad},supportsFullBroadcast$8=!1,equalConfig=createBinaryKernelConfig(Equal,!1,"bool"),erfConfig=createUnaryKernelConfig(Erf),expConfig=createUnaryKernelConfig(Exp,"float32");function expandDims(e){const{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,u=r.shape.slice();let o=s;return s<0&&(util.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),o=i+s+1),u.splice(o,0,1),reshape({inputs:{x:r},backend:a,attrs:{shape:u}})}const expandDimsConfig={kernelName:ExpandDims,backendName:"wasm",kernelFunc:expandDims},expm1Config=createUnaryKernelConfig(Expm1,"float32");function fill(e){const{attrs:{shape:t,value:n},backend:a}=e;let{attrs:{dtype:r}}=e;r=r||util.inferDtype(n);const s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}const fillConfig={kernelName:Fill,backendName:"wasm",kernelFunc:fill};let wasmFlipLeftRight;function setup$L(e){wasmFlipLeftRight=e.wasm.cwrap(FlipLeftRight,null,["number","number","number","number","number","number"])}function flipLeftRight(e){const{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[u,o,p,d]=a.shape;return wasmFlipLeftRight(s,u,o,p,d,i),r}const flipLeftRightConfig={kernelName:FlipLeftRight,backendName:"wasm",kernelFunc:flipLeftRight,setupFunc:setup$L},floorConfig=createUnaryKernelConfig(Floor),floorDivConfig=createBinaryKernelConfig(FloorDiv);let wasmBatchNorm;function setup$K(e){wasmBatchNorm=e.wasm.cwrap(FusedBatchNorm,null,["number","number","number","number","number","number","number"])}function fusedBatchNorm(e){const{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:u,offset:o,scale:p}=n,d=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(u.dataId).id,m=null!=o?t.dataIdMap.get(o.dataId).id:0,f=null!=p?t.dataIdMap.get(p.dataId).id:0,h=t.makeOutput(s.shape,s.dtype);if(0===util.sizeFromShape(s.shape))return h;const g=t.dataIdMap.get(h.dataId).id;return wasmBatchNorm(d,l,c,m,f,r,g),h}const fusedBatchNormConfig={kernelName:FusedBatchNorm,backendName:"wasm",setupFunc:setup$K,kernelFunc:fusedBatchNorm};let wasmFusedConv2d;function setup$J(e){wasmFusedConv2d=e.wasm.cwrap(FusedConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fusedConv2d(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:u}=t,{strides:o,pad:p,dilations:d,dataFormat:l,dimRoundingMode:c,activation:m,leakyreluAlpha:f}=n,h=backend_util.computeConv2DInfo(r.shape,s.shape,o,d,p,c),g=FusableActivation[m];if(null==g)throw new Error(`${m} activation not yet supported for FusedConv2D in the wasm backend.`);const b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,_=h.outChannels;let w=0;if(null!=i){const e=a.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==_)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${_})`);w=e.id}const k=h.filterHeight,I=h.filterWidth,S=h.padInfo.top,M=h.padInfo.right,C=h.padInfo.bottom,D=h.padInfo.left,A=h.dilationHeight,v=h.dilationWidth,x=h.strideHeight,F=h.strideWidth,N=h.inChannels,R="SAME"===h.padInfo.type?1:0,P=h.batchSize,T=h.inHeight,B=h.inWidth;if("NHWC"!==l)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${l}'. Please use 'NHWC'.`);const E=a.makeOutput(h.outShape,"float32"),W=a.dataIdMap.get(E.dataId).id,$=null==u?0:a.dataIdMap.get(u.dataId).id;return wasmFusedConv2d(b,P,T,B,y,k,I,w,S,M,C,D,R,A,v,x,F,N,_,g,$,f||0,W),E}const fusedConv2DConfig={kernelName:FusedConv2D,backendName:"wasm",setupFunc:setup$J,kernelFunc:fusedConv2d};let wasmFusedDepthwiseConv2d;function setup$I(e){wasmFusedDepthwiseConv2d=e.wasm.cwrap(FusedDepthwiseConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fusedDepthwiseConv2d(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:u}=t,{strides:o,pad:p,dilations:d,dataFormat:l,dimRoundingMode:c,activation:m,leakyreluAlpha:f}=n,h=backend_util.computeConv2DInfo(r.shape,s.shape,o,d,p,c,!0),g=FusableActivation[m];if(null==g)throw new Error(`${m} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,_=h.outChannels;let w=0;if(null!=i){const e=a.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==_)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${_})`);w=e.id}const k=h.filterHeight,I=h.filterWidth,S=h.padInfo.top,M=h.padInfo.right,C=h.padInfo.bottom,D=h.padInfo.left,A=h.dilationHeight,v=h.dilationWidth,x=h.strideHeight,F=h.strideWidth,N=h.inChannels,R="SAME"===h.padInfo.type?1:0,P=h.batchSize,T=h.inHeight,B=h.inWidth;if("NHWC"!==l)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${l}'. Please use 'NHWC'.`);const E=a.makeOutput(h.outShape,"float32"),W=a.dataIdMap.get(E.dataId).id,$=null==u?0:a.dataIdMap.get(u.dataId).id;return wasmFusedDepthwiseConv2d(b,P,T,B,y,k,I,w,S,M,C,D,R,A,v,x,F,N,_,g,$,f||0,W),E}const fusedDepthwiseConv2DConfig={kernelName:FusedDepthwiseConv2D,backendName:"wasm",setupFunc:setup$I,kernelFunc:fusedDepthwiseConv2d};let wasmGatherNd;function setup$H(e){wasmGatherNd=e.wasm.cwrap(GatherNd,null,["number","number","number","number","number","number","array","number"])}function gatherNd(e){const{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,u,o]=gather_util.prepareAndValidate(a,r),p=t.makeOutput(s,a.dtype);if(0===i)return p;const d=r.shape,l=d[d.length-1],c=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(r.dataId).id,f=new Uint8Array(new Int32Array(o).buffer),h=t.dataIdMap.get(p.dataId).id;return wasmGatherNd(c,CppDType[a.dtype],m,i,l,u,f,h),p}const gatherNdConfig={kernelName:GatherNd,backendName:"wasm",setupFunc:setup$H,kernelFunc:gatherNd};let wasmGather;function setup$G(e){wasmGather=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function gatherV2(e){const{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:u}=a,o=util.parseAxisParam(i,r.shape)[0],p=t.readSync(s.dataId),d=r.shape[o];for(let e=0;e<p.length;++e){const t=p[e];util.assert(t<=d-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${d-1}]`))}const l=backend_util.segment_util.collectGatherOpShapeInfo(r,s,o,u),c=reshape({inputs:{x:r},attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]},backend:t}),m=util.sizeFromShape(s.shape),f=reshape({inputs:{x:s},attrs:{shape:[l.batchSize,m/l.batchSize]},backend:t}),h=[l.batchSize,l.outerSize,m/l.batchSize,l.sliceSize],g=t.makeOutput(h,r.dtype);if(0===util.sizeFromShape(r.shape))return g;const b=c.shape.length-1,y=t.dataIdMap.get(c.dataId).id,_=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,k=new Uint8Array(new Int32Array(util.computeStrides(c.shape)).buffer),I=new Uint8Array(new Int32Array(util.computeStrides(h)).buffer);return wasmGather(y,CppDType[r.dtype],k,b,_,l.batchSize,I,w),t.disposeData(c.dataId),t.disposeData(f.dataId),g.shape=l.outputShape,g}const gatherV2Config={kernelName:GatherV2,backendName:"wasm",setupFunc:setup$G,kernelFunc:gatherV2},supportsFullBroadcast$7=!1,greaterConfig=createBinaryKernelConfig(Greater,!1,"bool"),supportsFullBroadcast$6=!1,greaterEqualConfig=createBinaryKernelConfig(GreaterEqual,!1,"bool"),isFiniteConfig=createUnaryKernelConfig(IsFinite,"bool"),isInfConfig=createUnaryKernelConfig(IsInf,"bool"),isNaNConfig=createUnaryKernelConfig(IsNan,"bool");let wasmFunc$5;function setupFunc(e){wasmFunc$5=e.wasm.cwrap(LeakyRelu,null,["number","number","number","number"])}function leakyRelu(e){const{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,"float32");if(0!==util.sizeFromShape(t.shape)){const e=a.dataIdMap.get(s.dataId).id;wasmFunc$5(r,CppDType[t.dtype],n,e)}return s}const leakyReluConfig={kernelName:LeakyRelu,backendName:"wasm",setupFunc,kernelFunc:leakyRelu},supportsFullBroadcast$5=!1,lessConfig=createBinaryKernelConfig(Less,!1,"bool"),supportsFullBroadcast$4=!1,lessEqualConfig=createBinaryKernelConfig(LessEqual,!1,"bool");let wasmLinSpace;function setup$F(e){wasmLinSpace=e.wasm.cwrap(LinSpace,null,["number","number","number","number"])}function linSpace(e){const{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),u=n.makeOutput([i],"float32");return wasmLinSpace(n.dataIdMap.get(u.dataId).id,a,r,i),u}const linSpaceConfig={kernelName:LinSpace,backendName:"wasm",setupFunc:setup$F,kernelFunc:linSpace},logConfig=createUnaryKernelConfig(Log),log1pConfig=createUnaryKernelConfig(Log1p),supportsFullBroadcast$3=!1,logicalAndConfig=createBinaryKernelConfig(LogicalAnd,!1,"bool"),logicalNotConfig=createUnaryKernelConfig(LogicalNot),supportsFullBroadcast$2=!1,logicalOrConfig=createBinaryKernelConfig(LogicalOr,!1,"bool"),supportsFullBroadcast$1=!1,logicalXorConfig=createBinaryKernelConfig(LogicalXor,!1,"bool");let wasmLRN;function setup$E(e){wasmLRN=e.wasm.cwrap(LRN,null,["number","number","number","number","number","number","number"])}function lrn(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:u,beta:o}=a;if("float32"!==r.dtype)throw new Error("LRN error: x must have dtype float32");const p=n.makeOutput(r.shape,r.dtype);return wasmLRN(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,r.shape[3],s,i,u,o),p}const lrnConfig={kernelName:LRN,backendName:"wasm",setupFunc:setup$E,kernelFunc:lrn};let wasmLRNGrad;function setup$D(e){wasmLRNGrad=e.wasm.cwrap(LRNGrad,null,["number","number","number","number","number","number","number","number","number"])}function lrnGrad(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:u,bias:o,alpha:p,beta:d}=a;if("float32"!==r.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");const l=n.makeOutput(r.shape,r.dtype);return wasmLRNGrad(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(l.dataId).id,i.shape[3],u,o,p,d),l}const lrnGradConfig={kernelName:LRNGrad,backendName:"wasm",setupFunc:setup$D,kernelFunc:lrnGrad};let wasmMax;function setup$C(e){wasmMax=e.wasm.cwrap(Max,null,["number","number","number","number"])}function max(e){const{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n;let u=t.dataIdMap.get(i.dataId).id,o=i;const{transposed:p,axes:d,originalAxes:l,inputWasTransposed:c}=permuteAxesAndTranspose(i,r,t);c&&(o=p,u=t.dataIdMap.get(p.dataId).id);const m=o.shape.length;backend_util.assertAxesAreInnerMostDims("max",d,m);const[f,h]=backend_util.computeOutAndReduceShapes(o.shape,d),g=util.sizeFromShape(h),b=t.makeOutput(f,i.dtype);if(0!==util.sizeFromShape(o.shape)){const e=t.dataIdMap.get(b.dataId).id;wasmMax(u,CppDType[i.dtype],g,e)}if(c&&t.disposeData(p.dataId),s){const e=backend_util.expandShapeToKeepDim(b.shape,l);b.shape=e}return b}const maxConfig={kernelName:Max,backendName:"wasm",setupFunc:setup$C,kernelFunc:max},maximumConfig=createBinaryKernelConfig(Maximum);let wasmMaxPool;function setup$B(e){wasmMaxPool=e.wasm.cwrap(MaxPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function maxPool(e){const{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;util.assert("float32"===r.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`));const{filterSize:i,strides:u,pad:o,dimRoundingMode:p}=n,d=backend_util.computePool2DInfo(r.shape,i,u,1,o,p),l=d.filterHeight,c=d.filterWidth,m=d.padInfo.top,f=d.padInfo.right,h=d.padInfo.bottom,g=d.padInfo.left,b=d.dilationHeight,y=d.dilationWidth,_=d.strideHeight,w=d.strideWidth,k=d.inChannels,I=d.outChannels;if("channelsLast"!==d.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);const S=a.makeOutput(d.outShape,"float32"),M=a.dataIdMap.get(S.dataId).id;return wasmMaxPool(s,r.shape[0],r.shape[1],r.shape[2],l,c,m,f,h,g,b,y,_,w,k,I,M),S}const maxPoolConfig={kernelName:MaxPool,backendName:"wasm",setupFunc:setup$B,kernelFunc:maxPool};let wasmMaxPool3D;function setup$A(e){wasmMaxPool3D=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function maxPool3D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:u,dimRoundingMode:o,dataFormat:p}=a,d=backend_util.computePool3DInfo(r.shape,s,i,1,u,o,p),l=n.makeOutput(d.outShape,r.dtype);return wasmMaxPool3D(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),l}const maxPool3DConfig={kernelName:MaxPool3D,backendName:"wasm",setupFunc:setup$A,kernelFunc:maxPool3D};let wasmMaxPool3DGrad;function setup$z(e){wasmMaxPool3DGrad=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function maxPool3DGrad(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:u,pad:o,dimRoundingMode:p}=a,d=backend_util.computePool3DInfo(s.shape,i,u,1,o,p),l=n.makeOutput(s.shape,s.dtype);return wasmMaxPool3DGrad(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),l}const maxPool3DGradConfig={kernelName:MaxPool3DGrad,backendName:"wasm",setupFunc:setup$z,kernelFunc:maxPool3DGrad};let wasmMaxPoolGrad;function setup$y(e){wasmMaxPoolGrad=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function maxPoolGrad(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:u,pad:o,dimRoundingMode:p}=a,d=backend_util.computePool2DInfo(s.shape,i,u,1,o,p),l=n.makeOutput(s.shape,s.dtype);return wasmMaxPoolGrad(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left),l}const maxPoolGradConfig={kernelName:MaxPoolGrad,backendName:"wasm",setupFunc:setup$y,kernelFunc:maxPoolGrad};let wasmMaxPoolWithArgmax;function setup$x(e){wasmMaxPoolWithArgmax=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function maxPoolWithArgmax(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:u,includeBatchInIndex:o}=a;util.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const p=[1,1];util.assert(backend_util.eitherStridesOrDilationsAreOne(i,p),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));const d=backend_util.computePool2DInfo(r.shape,s,i,[1,1],u),l=n.makeOutput(d.outShape,r.dtype),c=n.makeOutput(d.outShape,"int32");return wasmMaxPoolWithArgmax(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,n.dataIdMap.get(c.dataId).id,CppDType[r.dtype],o,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left),[l,c]}const maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"wasm",setupFunc:setup$x,kernelFunc:maxPoolWithArgmax};let wasmMean;function setup$w(e){wasmMean=e.wasm.cwrap(Mean,null,["number, number, number"])}function mean(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,u=t.dataIdMap.get(i.dataId).id;let o=u,p=i;const{transposed:d,axes:l,originalAxes:c,inputWasTransposed:m}=permuteAxesAndTranspose(i,r,t);let f=l;if(m){const e=t.dataIdMap.get(d.dataId).id;e!==u&&(p=d,o=e,f=backend_util.getInnerMostAxes(f.length,p.shape.length))}backend_util.assertAxesAreInnerMostDims("mean",f,p.shape.length);const[h,g]=backend_util.computeOutAndReduceShapes(p.shape,f),b=util.sizeFromShape(g);let y=p;"float32"!==p.dtype&&(y=cast({backend:t,inputs:{x:p},attrs:{dtype:"float32"}}),o=t.dataIdMap.get(y.dataId).id);const _=t.makeOutput(h,"float32");if(0!==util.sizeFromShape(p.shape)){const e=t.dataIdMap.get(_.dataId).id;wasmMean(o,b,e)}if(m&&t.disposeData(d.dataId),s){const e=backend_util.expandShapeToKeepDim(_.shape,c);_.shape=e}return"float32"!==p.dtype&&t.disposeData(y.dataId),_}const meanConfig={kernelName:Mean,backendName:"wasm",setupFunc:setup$w,kernelFunc:mean};let wasmMin;function setup$v(e){wasmMin=e.wasm.cwrap(Min,null,["number","number","number","number"])}function min(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,u=t.dataIdMap.get(i.dataId).id;let o=u,p=i;const{transposed:d,axes:l,originalAxes:c,inputWasTransposed:m}=permuteAxesAndTranspose(i,r,t);if(m){const e=t.dataIdMap.get(d.dataId).id;e!==u&&(p=d,o=e)}const f=p.shape.length;backend_util.assertAxesAreInnerMostDims("min",l,f);const[h,g]=backend_util.computeOutAndReduceShapes(p.shape,l),b=util.sizeFromShape(g),y=t.makeOutput(h,p.dtype);if(0!==util.sizeFromShape(p.shape)){const e=t.dataIdMap.get(y.dataId).id;wasmMin(o,CppDType[i.dtype],b,e)}if(m&&t.disposeData(d.dataId),s){const e=backend_util.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}const minConfig={kernelName:Min,backendName:"wasm",setupFunc:setup$v,kernelFunc:min},minimumConfig=createBinaryKernelConfig(Minimum);var MirrorPaddingMode;let wasmMirrorPad;function setup$u(e){wasmMirrorPad=e.wasm.cwrap(MirrorPad,null,["number","array","number","number","array","array","number","number"])}function mirrorPad(e){const{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,u=n.makeOutput(s,t.dtype),o=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),d=a.map((e=>e[0])),l=a.map((e=>e[1])),c=new Uint8Array(new Int32Array(d).buffer),m=new Uint8Array(new Int32Array(l).buffer);return wasmMirrorPad(i,p,t.shape.length,CppDType[t.dtype],c,m,MirrorPaddingMode[r],o),u}!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(MirrorPaddingMode||(MirrorPaddingMode={}));const mirrorPadConfig={kernelName:MirrorPad,backendName:"wasm",kernelFunc:mirrorPad,setupFunc:setup$u};let wasmFunc$4;function setup$t(e){wasmFunc$4=e.wasm.cwrap(Softmax,null,["number","number","number","number"])}function softmax(e){const{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,u=n.shape[a],o=util.sizeFromShape(n.shape)/u;return 0===util.sizeFromShape(s.shape)||wasmFunc$4(r,i,u,o),s}const softmaxConfig={kernelName:Softmax,backendName:"wasm",setupFunc:setup$t,kernelFunc:softmax};let wasmMultinomial;function setup$s(e){wasmMultinomial=e.wasm.cwrap(Multinomial,null,["number","number","number","number","number","number"])}function multinomial(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:u}=a;if("float32"!==r.dtype)throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);const o=u?r:softmax({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[p,d]=o.shape,l=n.makeOutput([p,s],"int32");return wasmMultinomial(n.dataIdMap.get(o.dataId).id,p,d,s,i,n.dataIdMap.get(l.dataId).id),u||n.disposeData(o.dataId),l}const multinomialConfig={kernelName:Multinomial,backendName:"wasm",setupFunc:setup$s,kernelFunc:multinomial},modConfig=createBinaryKernelConfig(Mod),multiplyConfig=createBinaryKernelConfig(Multiply),negConfig=createUnaryKernelConfig(Neg);function parseResultStruct(e,t){const n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}let wasmFunc$3;function setup$r(e){wasmFunc$3=e.wasm.cwrap(NonMaxSuppressionV3,"number",["number","number","number","number","number"])}function kernelFunc$1(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:u,scores:o}=n,p=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(o.dataId).id,l=wasmFunc$3(p,d,s,r,i),{pSelectedIndices:c,selectedSize:m,pSelectedScores:f,pValidOutputs:h}=parseResultStruct(t,l);return t.wasm._free(f),t.wasm._free(h),t.makeOutput([m],"int32",c)}const nonMaxSuppressionV3Config={kernelName:NonMaxSuppressionV3,backendName:"wasm",setupFunc:setup$r,kernelFunc:kernelFunc$1};let wasmFunc$2;function setup$q(e){wasmFunc$2=e.wasm.cwrap(NonMaxSuppressionV4,"number",["number","number","number","number","number","bool"])}function nonMaxSuppressionV4(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:u}=a,{boxes:o,scores:p}=n,d=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(p.dataId).id,c=wasmFunc$2(d,l,s,r,i,u),{pSelectedIndices:m,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=parseResultStruct(t,c);return t.wasm._free(h),[t.makeOutput([f],"int32",m),t.makeOutput([],"int32",g)]}const nonMaxSuppressionV4Config={kernelName:NonMaxSuppressionV4,backendName:"wasm",setupFunc:setup$q,kernelFunc:nonMaxSuppressionV4};let wasmFunc$1;function setup$p(e){wasmFunc$1=e.wasm.cwrap(NonMaxSuppressionV5,"number",["number","number","number","number","number","number"])}function kernelFunc(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:u}=a,{boxes:o,scores:p}=n,d=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(p.dataId).id,c=wasmFunc$1(d,l,s,r,i,u),{pSelectedIndices:m,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=parseResultStruct(t,c);return t.wasm._free(g),[t.makeOutput([f],"int32",m),t.makeOutput([f],"float32",h)]}const nonMaxSuppressionV5Config={kernelName:NonMaxSuppressionV5,backendName:"wasm",setupFunc:setup$p,kernelFunc},supportsFullBroadcast=!1,notEqualConfig=createBinaryKernelConfig(NotEqual,!1,"bool");let wasmOneHot;function setup$o(e){wasmOneHot=e.wasm.cwrap(OneHot,null,["number","number","number","number","number"])}function oneHot(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:u,offValue:o}=a,p=n.makeOutput([...r.shape,i],s),d=n.dataIdMap.get(p.dataId).id,l=n.dataIdMap.get(r.dataId).id;return wasmOneHot(l,i,u,o,d),p}const oneHotConfig={kernelName:OneHot,backendName:"wasm",setupFunc:setup$o,kernelFunc:oneHot};function onesLike(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}const onesLikeConfig={kernelName:OnesLike,backendName:"wasm",kernelFunc:onesLike};function pack(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return expandDims({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{util.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),util.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],o=concat({inputs:t.map((e=>{const t=expandDims({inputs:{input:e},backend:n,attrs:{dim:r}});return u.push(t),t})),backend:n,attrs:{axis:r}});return u.forEach((e=>n.disposeData(e.dataId))),o}const packConfig={kernelName:Pack,backendName:"wasm",kernelFunc:pack};let wasmPadV2;function setup$n(e){wasmPadV2=e.wasm.cwrap(PadV2,null,["number","array","number","number","array","array","number","number"])}function pad(e){const{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===util.sizeFromShape(t.shape))return fill({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});const i=n.dataIdMap.get(t.dataId).id,u=n.makeOutput(s,t.dtype),o=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),d=a.map((e=>e[0])),l=a.map((e=>e[1])),c=new Uint8Array(new Int32Array(d).buffer),m=new Uint8Array(new Int32Array(l).buffer);return wasmPadV2(i,p,t.shape.length,CppDType[t.dtype],c,m,r,o),u}const padV2Config={kernelName:PadV2,backendName:"wasm",kernelFunc:pad,setupFunc:setup$n},powConfig=createBinaryKernelConfig(Pow);let wasmPrelu;function setup$m(e){wasmPrelu=e.wasm.cwrap(Prelu,null,["number","number","number"])}function prelu(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id;let u=s;const o=a;let p=o;"float32"!==o.dtype&&(p=cast({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(p.dataId).id);const d=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(d.dataId).id;return wasmPrelu(u,i,l),"float32"!==o.dtype&&n.disposeData(p.dataId),d}const preluConfig={kernelName:Prelu,backendName:"wasm",setupFunc:setup$m,kernelFunc:prelu};let wasmProd;function setup$l(e){wasmProd=e.wasm.cwrap(Prod,null,["number","number","number","number"])}function prod(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,u=t.dataIdMap.get(i.dataId).id;let o=u,p=i;const{transposed:d,axes:l,originalAxes:c,inputWasTransposed:m}=permuteAxesAndTranspose(i,r,t);let f=l;if(m){const e=t.dataIdMap.get(d.dataId).id;e!==u&&(p=d,o=e,f=backend_util.getInnerMostAxes(f.length,p.shape.length))}backend_util.assertAxesAreInnerMostDims("prod",f,p.shape.length);const[h,g]=backend_util.computeOutAndReduceShapes(p.shape,f),b=util.sizeFromShape(g),y=t.makeOutput(h,p.dtype);if(0!==util.sizeFromShape(p.shape)){const e=t.dataIdMap.get(y.dataId).id;wasmProd(o,b,CppDType[y.dtype],e)}if(m&&t.disposeData(d.dataId),s){const e=backend_util.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}const prodConfig={kernelName:Prod,backendName:"wasm",setupFunc:setup$l,kernelFunc:prod},range=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,u=rangeImpl(a,r,s,i),o=t.makeOutput([u.length],i);return t.typedArrayFromHeap(o).set(u),o},rangeConfig={kernelName:Range,backendName:"wasm",kernelFunc:range},realDivConfig=createBinaryKernelConfig(RealDiv),reciprocalConfig=createUnaryKernelConfig(Reciprocal),reluConfig=createUnaryKernelConfig(Relu),relu6Config=createUnaryKernelConfig(Relu6);let wasmResizeBilinear;function setup$k(e){wasmResizeBilinear=e.wasm.cwrap(ResizeBilinear,null,["number","number","number","number","number","number","number","number","number","number"])}function resizeBilinear(e){const{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:u}=a,[o,p]=u,[d,l,c,m]=r.shape,f=[d,o,p,m];let h,g=t.dataIdMap.get(r.dataId);"float32"!==g.dtype&&(h=cast({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(h.dataId));const b=g.id,y=t.makeOutput(f,"float32");if(0===util.sizeFromShape(r.shape))return y;const _=t.dataIdMap.get(y.dataId).id;return wasmResizeBilinear(b,d,l,c,m,o,p,s?1:0,i?1:0,_),null!=h&&t.disposeData(h.dataId),y}const resizeBilinearConfig={kernelName:ResizeBilinear,backendName:"wasm",setupFunc:setup$k,kernelFunc:resizeBilinear};let wasmResizeBilinearGrad;function setup$j(e){wasmResizeBilinearGrad=e.wasm.cwrap(ResizeBilinearGrad,null,["number","number","number","array","array","boolean"])}function resizeBilinearGrad(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,u=n.makeOutput(r.shape,"float32");let o,p=n.dataIdMap.get(r.dataId);return"float32"!==p.dtype&&(o=cast({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),p=n.dataIdMap.get(o.dataId)),wasmResizeBilinearGrad(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),null!=o&&n.disposeData(o.dataId),u}const resizeBilinearGradConfig={kernelName:ResizeBilinearGrad,backendName:"wasm",setupFunc:setup$j,kernelFunc:resizeBilinearGrad};let wasmResizeNearestNeighbor;function setup$i(e){wasmResizeNearestNeighbor=e.wasm.cwrap(ResizeNearestNeighbor,null,["number","number","number","number","number","number","number","number","number","number"])}function resizeNearestNeighbor(e){const{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:u}=a,[o,p]=u,[d,l,c,m]=r.shape,f=[d,o,p,m],h=t.makeOutput(f,"float32");if(0===util.sizeFromShape(r.shape))return h;let g,b=t.dataIdMap.get(r.dataId);"float32"!==b.dtype&&(g=cast({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(g.dataId));const y=b.id,_=t.dataIdMap.get(h.dataId).id;return wasmResizeNearestNeighbor(y,d,l,c,m,o,p,s?1:0,i?1:0,_),null!=g&&t.disposeData(g.dataId),h}const resizeNearestNeighborConfig={kernelName:ResizeNearestNeighbor,backendName:"wasm",setupFunc:setup$i,kernelFunc:resizeNearestNeighbor};let wasmResizeNearestNeighborGrad;function setup$h(e){wasmResizeNearestNeighborGrad=e.wasm.cwrap(ResizeNearestNeighborGrad,null,["number","number","number","array","array","boolean"])}function resizeNearestNeighborGrad(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,u=n.makeOutput(r.shape,"float32");let o,p=n.dataIdMap.get(r.dataId);return"float32"!==p.dtype&&(o=cast({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),p=n.dataIdMap.get(o.dataId)),wasmResizeNearestNeighborGrad(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),null!=o&&n.disposeData(o.dataId),u}const resizeNearestNeighborGradConfig={kernelName:ResizeNearestNeighborGrad,backendName:"wasm",setupFunc:setup$h,kernelFunc:resizeNearestNeighborGrad};let wasmReverse;function setup$g(e){wasmReverse=e.wasm.cwrap(Reverse,null,["number","array","number","array","number","number"])}function reverse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=util.parseAxisParam(s,r.shape);if(0===r.shape.length)return identity({inputs:{x:r},backend:n});const u=n.makeOutput(r.shape,r.dtype),o=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(u.dataId).id,d=new Uint8Array(new Int32Array(i).buffer),l=new Uint8Array(new Int32Array(r.shape).buffer);wasmReverse(o,d,i.length,l,r.shape.length,p);const c=reshape({inputs:{x:u},attrs:{shape:r.shape},backend:n});return n.disposeData(u.dataId),c}const reverseConfig={kernelName:Reverse,backendName:"wasm",kernelFunc:reverse,setupFunc:setup$g};let wasmRotate;function setup$f(e){wasmRotate=e.wasm.cwrap(RotateWithOffset,null,["number","number","number","number","number","number","number","number","array","number","number"])}function rotateWithOffset(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:u}=a,o=n.makeOutput(r.shape,r.dtype),p=n.dataIdMap.get(r.dataId).id,d=n.dataIdMap.get(o.dataId).id,[l,c,m,f]=r.shape,[h,g]=backend_util.getImageCenter(u,c,m),b="number"==typeof i?[i,i,i,0===i?0:255]:[...i,255],y=new Uint8Array(new Int32Array(b).buffer);return wasmRotate(p,l,c,m,f,s,h,g,y,b.length,d),o}const rotateWithOffsetConfig={kernelName:RotateWithOffset,backendName:"wasm",kernelFunc:rotateWithOffset,setupFunc:setup$f},roundConfig=createUnaryKernelConfig(Round),rsqrtConfig=createUnaryKernelConfig(Rsqrt);let wasmScatterNd;function setup$e(e){wasmScatterNd=e.wasm.cwrap(ScatterNd,null,["number","number","number","number","number","number","array","number","number"])}function scatterNd(e){const{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,u=t.makeOutput(i,s.dtype);if(0===util.sizeFromShape(i))return u;const{sliceRank:o,numUpdates:p,sliceSize:d,strides:l,outputSize:c}=scatter_util.calculateShapes(s,r,i),m=t.dataIdMap.get(r.dataId).id,f=t.dataIdMap.get(s.dataId).id,h=new Uint8Array(new Int32Array(l).buffer),g=t.dataIdMap.get(u.dataId).id;return wasmScatterNd(m,f,CppDType[s.dtype],o,p,d,h,c,g),u}const scatterNdConfig={kernelName:ScatterNd,backendName:"wasm",setupFunc:setup$e,kernelFunc:scatterNd};let wasmSearchSorted;function setup$d(e){wasmSearchSorted=e.wasm.cwrap(SearchSorted,null,["number","number","number","number","number","number","bool","number"])}function searchSorted(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);const u=n.makeOutput(s.shape,"int32");function o(e){return n.dataIdMap.get(e.dataId).id}return wasmSearchSorted(o(r),o(s),r.shape[0],r.shape[1],s.shape[1],CppDType[r.dtype],"left"===i,o(u)),u}const searchSortedConfig={kernelName:SearchSorted,backendName:"wasm",setupFunc:setup$d,kernelFunc:searchSorted};let wasmSelect;function setup$c(e){wasmSelect=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function select(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,p=n.makeOutput(r.shape,r.dtype),d=n.dataIdMap.get(p.dataId).id,l=a.shape.length,c=r.shape.length,m=0===l||l>1||1===c?1:util.sizeFromShape(r.shape.slice(1));return wasmSelect(i,u,o,m,d),p}const selectConfig={kernelName:Select,backendName:"wasm",kernelFunc:select,setupFunc:setup$c},seluConfig=createUnaryKernelConfig(Selu);let wasmFunc;function setup$b(e){wasmFunc=e.wasm.cwrap(Sigmoid,null,["number","number"])}function sigmoid(e){const{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return 0===util.sizeFromShape(r.shape)||wasmFunc(a,s),r}const sigmoidConfig={kernelName:"Sigmoid",backendName:"wasm",setupFunc:setup$b,kernelFunc:sigmoid},signConfig=createUnaryKernelConfig(Sign),sinConfig=createUnaryKernelConfig(Sin),sinhConfig=createUnaryKernelConfig(Sinh),softplusConfig=createUnaryKernelConfig(Softplus);function spaceToBatchND(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,u=util.sizeFromShape(s),o=[[0,0]];o.push(...i);for(let e=1+s.length;e<r.shape.length;++e)o.push([0,0]);const p=padV2Config.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:o,constantValue:0}}),d=backend_util.getReshaped(p.shape,s,u,!1),l=backend_util.getPermuted(d.length,s.length,!1),c=backend_util.getReshapedPermuted(p.shape,s,u,!1),m=reshape({inputs:{x:p},backend:n,attrs:{shape:d}}),f=transpose({inputs:{x:m},backend:n,attrs:{perm:l}}),h=reshape({inputs:{x:f},backend:n,attrs:{shape:c}});return n.disposeData(p.dataId),n.disposeData(m.dataId),n.disposeData(f.dataId),h}const spaceToBatchNDConfig={kernelName:SpaceToBatchND,backendName:"wasm",kernelFunc:spaceToBatchND};let wasmSparseFillEmptyRows;function setup$a(e){wasmSparseFillEmptyRows=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function sparseFillEmptyRows(e){const{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=n,u=a.shape[0],o=a.shape[1],p=t.readSync(s.dataId)[0],d=[u+p,o],l=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(d,a.dtype),h=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(d.slice(0,1),r.dtype),b=t.dataIdMap.get(g.dataId).id,y=t.makeOutput([p],"bool"),_=t.dataIdMap.get(y.dataId).id,w=t.makeOutput([u],a.dtype),k=t.dataIdMap.get(w.dataId).id,I=t.makeOutput([4],"int32"),S=t.dataIdMap.get(I.dataId).id,M=wasmSparseFillEmptyRows(l,c,CppDType[r.dtype],u,p,o,m,h,b,_,k,S),C=t.readSync(I.dataId);let D;switch(C[0]){case 1:D=backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(C[1]);break;case 2:D=backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(C[1],C[2]);break;case 3:D=backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(C[1],C[2],C[3]);break;default:D=""}if(t.disposeData(I.dataId),D)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData(w.dataId),new Error(D);let A=f,v=g;return M!==d[0]&&(A=slice({inputs:{x:f},attrs:{begin:0,size:[M,o]},backend:t}),v=slice({inputs:{x:g},attrs:{begin:0,size:M},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[A,v,y,w]}const sparseFillEmptyRowsConfig={kernelName:SparseFillEmptyRows,backendName:"wasm",setupFunc:setup$a,kernelFunc:sparseFillEmptyRows};let wasmSparseReshape;function setup$9(e){wasmSparseReshape=e.wasm.cwrap(SparseReshape,null,["number","number","number","number","number","number","number"])}function sparseReshape(e){const{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=t.dataIdMap.get(a.dataId).id,u=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,p=a.shape[0],d=util.sizeFromShape(s.shape),l=t.makeOutput([p,d],a.dtype),c=t.dataIdMap.get(l.dataId).id,m=t.makeOutput([d],s.dtype),f=t.dataIdMap.get(m.dataId).id,h=t.makeOutput([3],"int32"),g=t.dataIdMap.get(h.dataId).id;wasmSparseReshape(i,u,o,p,c,f,g);const b=t.readSync(h.dataId);let y;switch(b[0]){case 0:y=backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=backend_util.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const e=Array.from(t.readSync(r.dataId)),n=Array.from(t.readSync(m.dataId));y=backend_util.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{const e=Array.from(t.readSync(r.dataId)),n=Array.from(t.readSync(m.dataId));y=backend_util.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(h.dataId),y)throw t.disposeData(l.dataId),t.disposeData(m.dataId),new Error(y);return[l,m]}const sparseReshapeConfig={kernelName:SparseReshape,backendName:"wasm",setupFunc:setup$9,kernelFunc:sparseReshape};let wasmSparseSegmentReduction;function setup$8(e){wasmSparseSegmentReduction=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function sparseSegmentReduction(e,t){const{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,u=s.shape[0],o=n.readSync(i.dataId,u-1,u)[0],p=u>0?o+1:0;if(p<0)throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const d=r.shape.slice();d[0]=p;const l=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(s.dataId).id,m=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(d,r.dtype),h=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),b=n.dataIdMap.get(g.dataId).id;wasmSparseSegmentReduction(l,CppDType[r.dtype],r.shape[0],c,m,h,b,t,0);const y=n.readSync(g.dataId);let _;switch(y[0]){case 0:_=backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:_=backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:_=backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y[1],y[2]);break;case 3:_=backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(y[1],y[2],y[3]);break;default:_=""}if(n.disposeData(g.dataId),_)throw n.disposeData(f.dataId),new Error(_);return f}function sparseSegmentMean(e){return sparseSegmentReduction(e,!0)}const sparseSegmentMeanConfig={kernelName:SparseSegmentMean,backendName:"wasm",setupFunc:setup$8,kernelFunc:sparseSegmentMean};function sparseSegmentSum(e){return sparseSegmentReduction(e,!1)}const sparseSegmentSumConfig={kernelName:SparseSegmentSum,backendName:"wasm",setupFunc:setup$8,kernelFunc:sparseSegmentSum};let wasmSparseToDense;function setup$7(e){wasmSparseToDense=e.wasm.cwrap(SparseToDense,null,["number","number","number","number","number","number","number","number","array","number","number"])}function sparseToDense(e){const{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:u}=a,o=t.makeOutput(u,i.dtype);if(0===util.sizeFromShape(u))return o;const{sliceRank:p,numUpdates:d,sliceSize:l,strides:c,outputSize:m}=backend_util.calculateShapes(s,r,u),f=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(c).buffer),y=t.dataIdMap.get(o.dataId).id;return wasmSparseToDense(f,h,s.shape.length,g,CppDType[i.dtype],p,d,l,b,m,y),o}const sparseToDenseConfig={kernelName:SparseToDense,backendName:"wasm",setupFunc:setup$7,kernelFunc:sparseToDense};function splitV(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,u=util.parseAxisParam(i,r.shape)[0],o=backend_util.prepareSplitSize(r,s,u),p=new Array(r.shape.length).fill(0),d=r.shape.slice();return o.map((e=>{const t=[...d];t[u]=e;const n=slice({inputs:{x:r},attrs:{begin:p,size:t},backend:a});return p[u]+=e,n}))}const splitVConfig={kernelName:SplitV,backendName:"wasm",kernelFunc:splitV},sqrtConfig=createUnaryKernelConfig(Sqrt),squareConfig=createUnaryKernelConfig(Square),squaredDifferenceConfig=createBinaryKernelConfig(SquaredDifference);let wasmStep;function setup$6(e){wasmStep=e.wasm.cwrap(Step,null,["number","number","number","number"])}function step(e){const{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,u=t.makeOutput(s.shape,s.dtype),o=t.dataIdMap.get(u.dataId).id;return wasmStep(i,r,CppDType[s.dtype],o),u}const stepConfig={kernelName:Step,backendName:"wasm",setupFunc:setup$6,kernelFunc:step};let wasmStridedSlice;function setup$5(e){wasmStridedSlice=e.wasm.cwrap(StridedSlice,null,["number","array","number","array","array","array","array","array","number","number"])}function stridedSlice(e){const{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:i,strides:u,beginMask:o,endMask:p,ellipsisMask:d,newAxisMask:l,shrinkAxisMask:c}=a,{finalShapeSparse:m,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:y,end:_,strides:w}=slice_util.sliceInfo(r.shape,s,i,u,o,p,d,l,c);let k;if(h)k=reshape({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||b){util.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=slice_util.computeOutShape(y,_,w),n=slice({inputs:{x:r},backend:t,attrs:{begin:y,size:e}});k=reshape({inputs:{x:n},backend:t,attrs:{shape:f}}),t.disposeData(n.dataId)}else{const e=t.makeOutput(m,"float32"),n=t.dataIdMap.get(r.dataId).id,a=new Uint8Array(new Int32Array(util.computeStrides(r.shape)).buffer),s=new Uint8Array(new Int32Array(y).buffer),i=new Uint8Array(new Int32Array(_).buffer),u=new Uint8Array(new Int32Array(w).buffer),o=new Uint8Array(new Int32Array(m).buffer),p=new Uint8Array(new Int32Array(util.computeStrides(m)).buffer),d=t.dataIdMap.get(e.dataId).id;wasmStridedSlice(n,a,r.shape.length,s,i,u,o,p,m.length,d),k=reshape({inputs:{x:e},backend:t,attrs:{shape:f}}),t.disposeData(e.dataId)}return k}const stridedSliceConfig={kernelName:StridedSlice,backendName:"wasm",setupFunc:setup$5,kernelFunc:stridedSlice};function stringNGrams(e){const{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:u,leftPad:o,rightPad:p,padWidth:d,preserveShortSequences:l}=a,c=t.readSync(r.dataId),m=t.readSync(s.dataId),[f,h]=stringNGramsImpl(c,m,i,u,o,p,d,l),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;const b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(h),[g,b]}const stringNGramsConfig={kernelName:StringNGrams,backendName:"wasm",kernelFunc:stringNGrams};function stringSplit(e){const{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,u=t.readSync(r.dataId),o=t.readSync(s.dataId),[p,d,l]=stringSplitImpl(u,o[0],i),c=d.length,m=t.makeOutput([c,2],"int32");t.typedArrayFromHeap(m).set(p);const f=t.makeOutput([c],"string");t.dataIdMap.get(f.dataId).stringBytes=d;const h=t.makeOutput([2],"int32");return t.typedArrayFromHeap(h).set(l),[m,f,h]}const stringSplitConfig={kernelName:StringSplit,backendName:"wasm",kernelFunc:stringSplit};function stringToHashBucketFast(e){const{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=stringToHashBucketFastImpl(t.readSync(r.dataId),s),u=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(u).set(i),u}const stringToHashBucketFastConfig={kernelName:StringToHashBucketFast,backendName:"wasm",kernelFunc:stringToHashBucketFast},subConfig=createBinaryKernelConfig(Sub);let wasmSum;function setup$4(e){wasmSum=e.wasm.cwrap(Sum,null,["number","number","number","number"])}function sum(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,u=t.dataIdMap.get(i.dataId).id;let o=u,p=i;const{transposed:d,axes:l,originalAxes:c,inputWasTransposed:m}=permuteAxesAndTranspose(i,r,t);let f=l;if(m){const e=t.dataIdMap.get(d.dataId).id;e!==u&&(p=d,o=e,f=backend_util.getInnerMostAxes(f.length,p.shape.length))}backend_util.assertAxesAreInnerMostDims("sum",f,p.shape.length);const[h,g]=backend_util.computeOutAndReduceShapes(p.shape,f),b=util.sizeFromShape(g),y=t.makeOutput(h,p.dtype);if(0!==util.sizeFromShape(p.shape)){const e=t.dataIdMap.get(y.dataId).id;wasmSum(o,b,CppDType[y.dtype],e)}if(m&&t.disposeData(d.dataId),s){const e=backend_util.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}const sumConfig={kernelName:Sum,backendName:"wasm",setupFunc:setup$4,kernelFunc:sum},tanConfig=createUnaryKernelConfig(Tan),tanhConfig=createUnaryKernelConfig(Tanh);let wasmTensorScatterUpdate;function setup$3(e){wasmTensorScatterUpdate=e.wasm.cwrap(TensorScatterUpdate,null,["number","number","number","number","number","number","array","number","number","number"])}function tensorScatterUpdate(e){const{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,u=t.makeOutput(r.shape,r.dtype);if(0===util.sizeFromShape(r.shape))return u;const{sliceRank:o,numUpdates:p,sliceSize:d,strides:l,outputSize:c}=scatter_util.calculateShapes(i,s,r.shape),m=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(l).buffer),b=t.dataIdMap.get(u.dataId).id;return wasmTensorScatterUpdate(m,f,CppDType[i.dtype],o,p,d,g,c,b,h),u}const tensorScatterUpdateConfig={kernelName:TensorScatterUpdate,backendName:"wasm",setupFunc:setup$3,kernelFunc:tensorScatterUpdate};let wasmTile;function setup$2(e){wasmTile=e.wasm.cwrap(Tile,null,["number","array","number","array","number","number"])}function tile(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,u=new Array(r.shape.length);for(let e=0;e<u.length;e++)u[e]=r.shape[e]*i[e];const o=new Uint8Array(new Int32Array(r.shape).buffer),p=new Uint8Array(new Int32Array(u).buffer),d=n.makeOutput(u,r.dtype),l=n.dataIdMap.get(d.dataId).id;return wasmTile(s,o,r.shape.length,p,u.length,CppDType[d.dtype],l),d}const tileConfig={kernelName:Tile,backendName:"wasm",setupFunc:setup$2,kernelFunc:tile};let wasmTopK;function setup$1(e){wasmTopK=e.wasm.cwrap(TopK,null,["number","array","number","number","number","bool","number","number"])}const topk=({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{k:r,sorted:s}=n,i=t.dataIdMap.get(a.dataId).id,u=new Uint8Array(new Int32Array(a.shape).buffer),o=a.shape.slice();o[o.length-1]=r;const p=t.makeOutput(o,a.dtype),d=t.dataIdMap.get(p.dataId).id,l=t.makeOutput(o,"int32"),c=t.dataIdMap.get(l.dataId).id;return wasmTopK(i,u,a.shape.length,CppDType[a.dtype],r,s,d,c),[p,l]},topKConfig={kernelName:TopK,backendName:"wasm",setupFunc:setup$1,kernelFunc:topk};let wasmTransform;function setup(e){wasmTransform=e.wasm.cwrap(Transform,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function transform(e){const{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:i,fillMode:u,fillValue:o,outputShape:p}=a,[d,l,c,m]=r.shape,[f,h]=null!=p?p:[l,c],g=[d,f,h,m],b=new Uint8Array(new Int32Array(util.computeStrides(r.shape)).buffer),y=new Uint8Array(new Int32Array(util.computeStrides(g)).buffer),_=t.makeOutput(g,r.dtype),w=t.dataIdMap.get(_.dataId).id,k=t.dataIdMap.get(r.dataId).id,I=t.dataIdMap.get(s.dataId).id,S="nearest"===i?1:2;let M;switch(u){case"constant":default:M=1;break;case"reflect":M=2;break;case"wrap":M=3;break;case"nearest":M=4}return wasmTransform(k,I,s.shape[0]>1,d,f,h,m,c,l,b,r.shape.length-1,y,g.length-1,S,M,o,w),_}const transformConfig={kernelName:Transform,backendName:"wasm",setupFunc:setup,kernelFunc:transform};function unique(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:u,indices:o}=uniqueImpl(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(u,s.dtype,void 0,i),a.makeOutput([o.length],"int32",void 0,o)]}const uniqueConfig={kernelName:Unique,backendName:"wasm",kernelFunc:unique};function unpack(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const i=r.shape[s],u=r.shape.length,o=new Array(u-1);let p=0;for(let e=0;e<u;e++)e!==s&&(o[p++]=r.shape[e]);const d=new Array(i),l=new Array(u).fill(0),c=r.shape.slice();c[s]=1;for(let e=0;e<d.length;e++)l[s]=e,d[e]=slice({inputs:{x:r},attrs:{begin:l,size:c},backend:n});return d.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:o})))}const unpackConfig={kernelName:Unpack,backendName:"wasm",kernelFunc:unpack};function zerosLike(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}const zerosLikeConfig={kernelName:ZerosLike,backendName:"wasm",kernelFunc:zerosLike},kernelConfigs=[_fusedMatMulConfig,absConfig,acosConfig,acoshConfig,addConfig,addNConfig,allConfig,anyConfig,argMaxConfig,argMinConfig,asinConfig,asinhConfig,atanConfig,atan2Config,atanhConfig,avgPoolConfig,avgPoolGradConfig,avgPool3DConfig,avgPool3DGradConfig,batchMatMulConfig,batchToSpaceNDConfig,bincountConfig,bitwiseAndConfig,broadcastArgsConfig,castConfig,ceilConfig,clipByValueConfig,concatConfig,conv2DConfig,conv2DBackpropInputConfig,conv3DConfig,conv3DBackpropFilterV2Config,conv3DBackpropInputV2Config,cosConfig,coshConfig,cropAndResizeConfig,cumprodConfig,cumsumConfig,denseBincountConfig,depthToSpaceConfig,depthwiseConv2dNativeConfig,diagConfig,dilation2DConfig,dilation2DBackpropFilterConfig,dilation2DBackpropInputConfig,eluConfig,eluGradConfig,equalConfig,erfConfig,expConfig,expandDimsConfig,expm1Config,fillConfig,flipLeftRightConfig,floorConfig,floorDivConfig,fusedBatchNormConfig,fusedConv2DConfig,fusedDepthwiseConv2DConfig,gatherNdConfig,gatherV2Config,greaterConfig,greaterEqualConfig,identityConfig,isFiniteConfig,isInfConfig,isNaNConfig,leakyReluConfig,lessConfig,lessEqualConfig,linSpaceConfig,log1pConfig,logConfig,logicalAndConfig,logicalNotConfig,logicalOrConfig,logicalXorConfig,lrnConfig,lrnGradConfig,maxConfig,maximumConfig,maxPoolConfig,maxPool3DConfig,maxPool3DGradConfig,maxPoolGradConfig,maxPoolWithArgmaxConfig,meanConfig,minConfig,minimumConfig,mirrorPadConfig,multinomialConfig,modConfig,multiplyConfig,negConfig,nonMaxSuppressionV3Config,nonMaxSuppressionV4Config,nonMaxSuppressionV5Config,notEqualConfig,oneHotConfig,onesLikeConfig,packConfig,padV2Config,powConfig,preluConfig,prodConfig,rangeConfig,realDivConfig,reciprocalConfig,reluConfig,relu6Config,reshapeConfig,resizeBilinearConfig,resizeBilinearGradConfig,resizeNearestNeighborConfig,resizeNearestNeighborGradConfig,reverseConfig,rotateWithOffsetConfig,roundConfig,rsqrtConfig,scatterNdConfig,searchSortedConfig,selectConfig,seluConfig,sigmoidConfig,signConfig,sinConfig,sinhConfig,sliceConfig,softmaxConfig,softplusConfig,spaceToBatchNDConfig,sparseFillEmptyRowsConfig,sparseReshapeConfig,sparseSegmentMeanConfig,sparseSegmentSumConfig,sparseToDenseConfig,splitVConfig,sqrtConfig,squareConfig,squaredDifferenceConfig,stepConfig,stridedSliceConfig,stringNGramsConfig,stringSplitConfig,stringToHashBucketFastConfig,subConfig,sumConfig,tanConfig,tanhConfig,tensorScatterUpdateConfig,tileConfig,topKConfig,transformConfig,transposeConfig,uniqueConfig,unpackConfig,zerosLikeConfig];for(const e of kernelConfigs)registerKernel(e);const ENV=env();ENV.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}})),ENV.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(ENV.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var tfjsBackendWasmThreadedSimd$1={exports:{}};!function(e){var t,n=(t="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(t=t||__filename),function(e){function n(){return x.buffer!=P&&L(x.buffer),T}function a(){return x.buffer!=P&&L(x.buffer),B}function r(){return x.buffer!=P&&L(x.buffer),E}function s(){return x.buffer!=P&&L(x.buffer),W}function i(){return x.buffer!=P&&L(x.buffer),$}var u,o,p,d=void 0!==(e=e||{})?e:{};d.ready=new Promise((function(e,t){u=e,o=t})),"undefined"!=typeof process&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var l,c,m,f=Object.assign({},d),h=(e,t)=>{throw t},g="object"==typeof window,b="function"==typeof importScripts,y="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,_=d.ENVIRONMENT_IS_PTHREAD||!1,w="";function k(e){return d.locateFile?d.locateFile(e,w):w+e}if(y){var I=require$$0,S=require$$1;let e;w=b?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=te(e)?new URL(e):S.normalize(e),I.readFileSync(e,t?void 0:"utf8")),m=e=>{var t=l(e,!0);return t.buffer||(t=new Uint8Array(t)),t},c=(e,t,n)=>{e=te(e)?new URL(e):S.normalize(e),I.readFile(e,(function(e,a){e?n(e):t(a.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof re))throw e})),process.on("unhandledRejection",(function(e){throw e})),h=(e,t)=>{if(K())throw process.exitCode=e,t;var n;(n=t)instanceof re||v("exiting due to exception: "+n),process.exit(e)},d.inspect=function(){return"[Emscripten Module object]"};try{e=require("worker_threads")}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}commonjsGlobal.Worker=e.Worker}else(g||b)&&(b?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),void 0!==t&&t&&(w=t),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",y||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},b&&(m=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),c=(e,t,n)=>{var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)}));y&&"undefined"==typeof performance&&(commonjsGlobal.performance=require$$3.performance);var M=console.log.bind(console),C=console.warn.bind(console);y&&(M=e=>I.writeSync(1,e+"\n"),C=e=>I.writeSync(2,e+"\n"));var D,A=d.print||M,v=d.printErr||C;Object.assign(d,f),f=null,d.arguments&&d.arguments,d.thisProgram&&d.thisProgram,d.quit&&(h=d.quit),d.wasmBinary&&(D=d.wasmBinary);var x,F,N=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&J("no native wasm support detected");var R,P,T,B,E,W,$,O=!1,z="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function G(e,t,n){for(var a=(t>>>=0)+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.buffer&&z)return z.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(var s="";t<r;){var i=e[t++];if(128&i){var u=63&e[t++];if(192!=(224&i)){var o=63&e[t++];if((i=224==(240&i)?(15&i)<<12|u<<6|o:(7&i)<<18|u<<12|o<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var p=i-65536;s+=String.fromCharCode(55296|p>>10,56320|1023&p)}}else s+=String.fromCharCode((31&i)<<6|u)}else s+=String.fromCharCode(i)}return s}function L(e){P=e,d.HEAP8=T=new Int8Array(e),d.HEAP16=new Int16Array(e),d.HEAP32=E=new Int32Array(e),d.HEAPU8=B=new Uint8Array(e),d.HEAPU16=new Uint16Array(e),d.HEAPU32=W=new Uint32Array(e),d.HEAPF32=new Float32Array(e),d.HEAPF64=$=new Float64Array(e)}_&&(P=d.buffer);var H,U=d.INITIAL_MEMORY||16777216;if(_)x=d.wasmMemory,P=d.buffer;else if(d.wasmMemory)x=d.wasmMemory;else if(!((x=new WebAssembly.Memory({initial:U/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw v("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),y&&v("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");x&&(P=x.buffer),U=P.byteLength,L(P);var V=[],j=[],q=[];function K(){return N}function X(){_||de(j)}var Q=0,Z=null;function J(e){d.onAbort&&d.onAbort(e),v(e="Aborted("+e+")"),O=!0,R=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw o(t),t}var Y;function ee(e){return e.startsWith("data:application/octet-stream;base64,")}function te(e){return e.startsWith("file://")}function ne(e){try{if(e==Y&&D)return new Uint8Array(D);if(m)return m(e);throw"both async and sync fetching of the wasm failed"}catch(e){J(e)}}ee(Y="tfjs-backend-wasm-threaded-simd.wasm")||(Y=k(Y));var ae={};function re(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){var t=pe.pthreads[e];t||J(undefined),pe.returnWorkerToPool(t)}function ie(e){var t=pe.getNewWorker();if(!t)return 6;pe.runningWorkers.push(t),pe.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{y&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function ue(e){if(_)return ye(1,1,e);R=e,K()||(pe.terminateAllThreads(),d.onExit&&d.onExit(e),O=!0),h(e,new re(e))}var oe=function(e,t){if(R=e,!t&&_)throw le(e),"unwind";ue(e)},pe={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){_?pe.initWorker():pe.initMainThread()},initMainThread:function(){for(var e=8;e--;)pe.allocateUnusedWorker()},initWorker:function(){N=!1},setExitStatus:function(e){R=e},terminateAllThreads:function(){for(var e of Object.values(pe.pthreads))pe.returnWorkerToPool(e);for(var e of pe.unusedWorkers)e.terminate();pe.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete pe.pthreads[t],pe.unusedWorkers.push(e),pe.runningWorkers.splice(pe.runningWorkers.indexOf(e),1),e.pthread_ptr=0,y&&e.unref(),We(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){pe.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(e,n){e.onmessage=t=>{var a,r=t.data,s=r.cmd;if(e.pthread_ptr&&(pe.currentProxiedOperationCallerThread=e.pthread_ptr),r.targetThread&&r.targetThread!=Fe()){var i=pe.pthreads[r.targetThread];return i?i.postMessage(r,r.transferList):v('Internal error! Worker sent a message "'+s+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(pe.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===s?ge(r.queue):"spawnThread"===s?ie(r):"cleanupThread"===s?se(r.thread):"killThread"===s?function(e){var t=pe.pthreads[e];delete pe.pthreads[e],t.terminate(),We(e),pe.runningWorkers.splice(pe.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===s?(a=r.thread,pe.pthreads[a].postMessage({cmd:"cancel"})):"loaded"===s?(e.loaded=!0,y&&e.unref(),n&&n(e),e.runPthread&&e.runPthread()):"print"===s?A("Thread "+r.threadId+": "+r.text):"printErr"===s?v("Thread "+r.threadId+": "+r.text):"alert"===s?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===s?d[r.handler](...r.args):s&&v("worker sent an unknown command "+s),pe.currentProxiedOperationCallerThread=void 0},e.onerror=e=>{throw v("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},y&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){})));var a=[];for(var r of["onExit","onAbort","print","printErr"])d.hasOwnProperty(r)&&a.push(r);e.postMessage({cmd:"load",handlers:a,urlOrBlob:d.mainScriptUrlOrBlob||t,wasmMemory:x,wasmModule:F})},allocateUnusedWorker:function(){var e,t=k("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),pe.unusedWorkers.push(e)},getNewWorker:function(){return 0==pe.unusedWorkers.length&&(pe.allocateUnusedWorker(),pe.loadWasmModuleToWorker(pe.unusedWorkers[0])),pe.unusedWorkers.pop()}};function de(e){for(;e.length>0;)e.shift()(d)}function le(e){if(_)return ye(2,0,e);try{oe(e)}catch(e){!function(e){if(e instanceof re||"unwind"==e)return R;h(1,e)}(e)}}d.PThread=pe,d.establishStackSpace=function(){var e=Fe(),t=r()[e+52>>>2],n=r()[e+56>>>2];Oe(t,t-n),Ge(t)};var ce,me=[];function fe(e,t,n,a){return _?ye(3,1,e,t,n,a):he(e,t,n,a)}function he(e,t,n,a){if("undefined"==typeof SharedArrayBuffer)return v("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var r=[];if(_&&0===r.length)return fe(e,t,n,a);var s={startRoutine:n,pthread_ptr:e,arg:a,transferList:r};return _?(s.cmd="spawnThread",postMessage(s,r),0):ie(s)}function ge(e){Atomics.store(r(),e>>2,1),Fe()&&Ee(e),Atomics.compareExchange(r(),e>>2,1,0)}function be(e){be.shown||(be.shown={}),be.shown[e]||(be.shown[e]=1,y&&(e="warning: "+e),v(e))}function ye(e,t){var n,a,r,s=arguments.length-2,u=arguments;return n=()=>{for(var n=s,a=Le(8*n),r=a>>3,o=0;o<s;o++){var p=u[2+o];i()[r+o>>>0]=p}return Re(e,n,a,t)},a=ze(),r=n(),Ge(a),r}d.invokeEntryPoint=function(e,t){var n,a,r=((a=me[n=e])||(n>=me.length&&(me.length=n+1),me[n]=a=H.get(n)),a)(t);K()?pe.setExitStatus(r):$e(r)},d.executeNotifiedProxyingQueue=ge,ce=y?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var _e=[];function we(e){try{return x.grow(e-P.byteLength+65535>>>16),L(x.buffer),1}catch(e){}}function ke(e){return _?ye(4,1,e):52}function Ie(e,t,n,a,r){return _?ye(5,1,e,t,n,a,r):70}var Se=[null,[],[]];function Me(e,t){var n=Se[e];0===t||10===t?((1===e?A:v)(G(n,0)),n.length=0):n.push(t)}function Ce(e,t,n,r){if(_)return ye(6,1,e,t,n,r);for(var i=0,u=0;u<n;u++){var o=s()[t>>>2],p=s()[t+4>>>2];t+=8;for(var d=0;d<p;d++)Me(e,a()[o+d>>>0]);i+=p}return s()[r>>>2]=i,0}function De(e){return d["_"+e]}function Ae(e,t,r,s,i){var u={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,a){if(!(a>0))return 0;for(var r=(n>>>=0)+a-1,s=0;s<e.length;++s){var i=e.charCodeAt(s);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),i<=127){if(n>=r)break;t[n++>>>0]=i}else if(i<=2047){if(n+1>=r)break;t[n++>>>0]=192|i>>6,t[n++>>>0]=128|63&i}else if(i<=65535){if(n+2>=r)break;t[n++>>>0]=224|i>>12,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}}t[n>>>0]=0}(e,a(),t,n)}(e,t=Le(n),n)}return t},array:e=>{var t=Le(e.length);return function(e,t){n().set(e,t>>>0)}(e,t),t}};var o=De(e),p=[],d=0;if(s)for(var l=0;l<s.length;l++){var c=u[r[l]];c?(0===d&&(d=ze()),p[l]=c(s[l])):p[l]=s[l]}var m=o.apply(null,p);return function(e){return 0!==d&&Ge(d),function(e){return"string"===t?(n=e,(n>>>=0)?G(a(),n,void 0):""):"boolean"===t?Boolean(e):e;var n}(e)}(m)}pe.init();var ve=[null,ue,le,fe,ke,Ie,Ce],xe={__emscripten_init_main_thread_js:function(e){Ne(e,!b,1,!g),pe.threadInitTLS()},__emscripten_thread_cleanup:function(e){_?postMessage({cmd:"cleanupThread",thread:e}):se(e)},__pthread_create_js:he,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(e,t,n,a){if(e==t)setTimeout((()=>ge(a)));else if(_)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:a});else{var r=pe.pthreads[e];if(!r)return;r.postMessage({cmd:"processProxyingQueue",queue:a})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){J("")},emscripten_check_blocking_allowed:function(){y||b||be("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:ce,emscripten_memcpy_big:function(e,t,n){a().copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_num_logical_cores:function(){return y?require$$4.cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){_e.length=t;for(var a=n>>3,r=0;r<t;r++)_e[r]=i()[a+r>>>0];return(e<0?ae[-e-1]:ve[e]).apply(null,_e)},emscripten_resize_heap:function(e){var t=a().length;if((e>>>=0)<=t)return!1;var n,r=4294901760;if(e>r)return!1;for(var s=1;s<=4;s*=2){var i=t*(1+.2/s);if(i=Math.min(i,e+100663296),we(Math.min(r,(n=Math.max(e,i))+(65536-n%65536)%65536)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:oe,fd_close:ke,fd_seek:Ie,fd_write:Ce,memory:x||d.wasmMemory};!function(){var e={env:xe,wasi_snapshot_preview1:xe};function t(e,t){var n,a,r=e.exports;if(d.asm=r,n=d.asm._emscripten_tls_init,pe.tlsInitFunctions.push(n),H=d.asm.__indirect_function_table,a=d.asm.__wasm_call_ctors,j.unshift(a),F=t,!_){var s=pe.unusedWorkers.length;pe.unusedWorkers.forEach((function(e){pe.loadWasmModuleToWorker(e,(function(){--s||function(){if(Q--,d.monitorRunDependencies&&d.monitorRunDependencies(Q),0==Q&&Z){var e=Z;Z=null,e()}}()}))}))}}function n(e){t(e.instance,e.module)}function a(t){return function(){if(!D&&(g||b)){if("function"==typeof fetch&&!te(Y))return fetch(Y,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Y+"'";return e.arrayBuffer()})).catch((function(){return ne(Y)}));if(c)return new Promise((function(e,t){c(Y,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ne(Y)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){v("failed to asynchronously prepare wasm: "+e),J(e)}))}if(_||(Q++,d.monitorRunDependencies&&d.monitorRunDependencies(Q)),d.instantiateWasm)try{return d.instantiateWasm(e,t)}catch(e){v("Module.instantiateWasm callback failed with error: "+e),o(e)}(D||"function"!=typeof WebAssembly.instantiateStreaming||ee(Y)||te(Y)||y||"function"!=typeof fetch?a(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return v("wasm streaming compile failed: "+e),v("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(o)}(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Acos=function(){return(d._Acos=d.asm.Acos).apply(null,arguments)},d._Acosh=function(){return(d._Acosh=d.asm.Acosh).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._ArgMin=function(){return(d._ArgMin=d.asm.ArgMin).apply(null,arguments)},d._Asin=function(){return(d._Asin=d.asm.Asin).apply(null,arguments)},d._Asinh=function(){return(d._Asinh=d.asm.Asinh).apply(null,arguments)},d._Atan=function(){return(d._Atan=d.asm.Atan).apply(null,arguments)},d._Atan2=function(){return(d._Atan2=d.asm.Atan2).apply(null,arguments)},d._Atanh=function(){return(d._Atanh=d.asm.Atanh).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._AvgPool3D=function(){return(d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},d._AvgPool3DGrad=function(){return(d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},d._AvgPoolGrad=function(){return(d._AvgPoolGrad=d.asm.AvgPoolGrad).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Bincount=function(){return(d._Bincount=d.asm.Bincount).apply(null,arguments)},d._BitwiseAnd=function(){return(d._BitwiseAnd=d.asm.BitwiseAnd).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Conv3D=function(){return(d._Conv3D=d.asm.Conv3D).apply(null,arguments)},d._Conv3DBackpropFilterV2=function(){return(d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},d._Conv3DBackpropInputV2=function(){return(d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DenseBincount=function(){return(d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Diag=function(){return(d._Diag=d.asm.Diag).apply(null,arguments)},d._Dilation2D=function(){return(d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},d._Dilation2DBackpropFilter=function(){return(d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},d._Dilation2DBackpropInput=function(){return(d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._EluGrad=function(){return(d._EluGrad=d.asm.EluGrad).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Erf=function(){return(d._Erf=d.asm.Erf).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._Expm1=function(){return(d._Expm1=d.asm.Expm1).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._IsFinite=function(){return(d._IsFinite=d.asm.IsFinite).apply(null,arguments)},d._IsInf=function(){return(d._IsInf=d.asm.IsInf).apply(null,arguments)},d._IsNan=function(){return(d._IsNan=d.asm.IsNan).apply(null,arguments)},d._LRN=function(){return(d._LRN=d.asm.LRN).apply(null,arguments)},d._LRNGrad=function(){return(d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._LinSpace=function(){return(d._LinSpace=d.asm.LinSpace).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._Log1p=function(){return(d._Log1p=d.asm.Log1p).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._LogicalNot=function(){return(d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},d._LogicalOr=function(){return(d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},d._LogicalXor=function(){return(d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._MaxPool3D=function(){return(d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},d._MaxPool3DGrad=function(){return(d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},d._MaxPoolGrad=function(){return(d._MaxPoolGrad=d.asm.MaxPoolGrad).apply(null,arguments)},d._MaxPoolWithArgmax=function(){return(d._MaxPoolWithArgmax=d.asm.MaxPoolWithArgmax).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Mod=function(){return(d._Mod=d.asm.Mod).apply(null,arguments)},d._Multinomial=function(){return(d._Multinomial=d.asm.Multinomial).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Reciprocal=function(){return(d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._ResizeBilinearGrad=function(){return(d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},d._ResizeNearestNeighbor=function(){return(d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},d._ResizeNearestNeighborGrad=function(){return(d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SearchSorted=function(){return(d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Selu=function(){return(d._Selu=d.asm.Selu).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sign=function(){return(d._Sign=d.asm.Sign).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Sinh=function(){return(d._Sinh=d.asm.Sinh).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._Softplus=function(){return(d._Softplus=d.asm.Softplus).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._SparseToDense=function(){return(d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._TensorScatterUpdate=function(){return(d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(d._malloc=d.asm.malloc).apply(null,arguments)},d._free=function(){return(d._free=d.asm.free).apply(null,arguments)},d.__emscripten_tls_init=function(){return(d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)};var Fe=d._pthread_self=function(){return(Fe=d._pthread_self=d.asm.pthread_self).apply(null,arguments)};d.___errno_location=function(){return(d.___errno_location=d.asm.__errno_location).apply(null,arguments)};var Ne=d.__emscripten_thread_init=function(){return(Ne=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)};d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d._emscripten_main_thread_process_queued_calls=function(){return(d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Re=d._emscripten_run_in_main_runtime_thread_js=function(){return(Re=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};d._emscripten_dispatch_to_thread_=function(){return(d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var Pe,Te,Be,Ee=d.__emscripten_proxy_execute_task_queue=function(){return(Ee=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},We=d.__emscripten_thread_free_data=function(){return(We=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},$e=d.__emscripten_thread_exit=function(){return($e=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},Oe=d._emscripten_stack_set_limits=function(){return(Oe=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},ze=d.stackSave=function(){return(ze=d.stackSave=d.asm.stackSave).apply(null,arguments)},Ge=d.stackRestore=function(){return(Ge=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},Le=d.stackAlloc=function(){return(Le=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)};function He(e){if(!(Q>0)){if(_)return u(d),X(),void startWorker(d);!function(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)e=d.preRun.shift(),V.unshift(e);var e;de(V)}(),Q>0||(d.setStatus?(d.setStatus("Running..."),setTimeout((function(){setTimeout((function(){d.setStatus("")}),1),t()}),1)):t())}function t(){Pe||(Pe=!0,d.calledRun=!0,O||(X(),u(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),function(){if(!_){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)e=d.postRun.shift(),q.unshift(e);var e;de(q)}}()))}}if(d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)},d.keepRuntimeAlive=K,d.wasmMemory=x,d.cwrap=function(e,t,n,a){var r=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&r&&!a?De(e):function(){return Ae(e,t,n,arguments)}},d.ExitStatus=re,d.PThread=pe,Z=function e(){Pe||He(),Pe||(Z=e)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(He(),p&&(Te={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!p.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!p.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Be=WasmBackendModule;else{if(void 0===e)throw new Error("Could not find wasm module in post.js");Be=e}if(Te){var Ue=Be._dispose;Be._dispose=function(){Ue(),Te.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Te.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});e.exports=n}(tfjsBackendWasmThreadedSimd$1);var tfjsBackendWasmThreadedSimdExports=tfjsBackendWasmThreadedSimd$1.exports,tfjsBackendWasmThreadedSimd=getDefaultExportFromCjs(tfjsBackendWasmThreadedSimdExports),wasmFactoryThreadedSimd_import=_mergeNamespaces({__proto__:null,default:tfjsBackendWasmThreadedSimd},[tfjsBackendWasmThreadedSimdExports]),wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};',tfjsBackendWasm$1={exports:{}};!function(e){var t,n=(t="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(t=t||__filename),function(e){var n,a,r,s=void 0!==(e=e||{})?e:{};s.ready=new Promise((function(e,t){n=e,a=t})),"undefined"!=typeof process&&process.listeners&&(r={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,u,o,p=Object.assign({},s),d="object"==typeof window,l="function"==typeof importScripts,c="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";if(c){var f=require$$0,h=require$$1;m=l?h.dirname(m)+"/":__dirname+"/",i=(e,t)=>(e=W(e)?new URL(e):h.normalize(e),f.readFileSync(e,t?void 0:"utf8")),o=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},u=(e,t,n)=>{e=W(e)?new URL(e):h.normalize(e),f.readFile(e,(function(e,a){e?n(e):t(a.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof O))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}}else(d||l)&&(l?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),t&&(m=t),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},l&&(o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),u=(e,t,n)=>{var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)});var g,b,y=s.print||console.log.bind(console),_=s.printErr||console.warn.bind(console);Object.assign(s,p),p=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit,s.wasmBinary&&(g=s.wasmBinary),s.noExitRuntime,"object"!=typeof WebAssembly&&P("no native wasm support detected");var w,k,I,S,M=!1,C="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function D(e,t,n){for(var a=(t>>>=0)+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.buffer&&C)return C.decode(e.subarray(t,r));for(var s="";t<r;){var i=e[t++];if(128&i){var u=63&e[t++];if(192!=(224&i)){var o=63&e[t++];if((i=224==(240&i)?(15&i)<<12|u<<6|o:(7&i)<<18|u<<12|o<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var p=i-65536;s+=String.fromCharCode(55296|p>>10,56320|1023&p)}}else s+=String.fromCharCode((31&i)<<6|u)}else s+=String.fromCharCode(i)}return s}function A(e){w=e,s.HEAP8=k=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=new Int32Array(e),s.HEAPU8=I=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=S=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var v=[],x=[],F=[],N=0,R=null;function P(e){s.onAbort&&s.onAbort(e),_(e="Aborted("+e+")"),M=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw a(t),t}var T,B;function E(e){return e.startsWith("data:application/octet-stream;base64,")}function W(e){return e.startsWith("file://")}function $(e){try{if(e==T&&g)return new Uint8Array(g);if(o)return o(e);throw"both async and sync fetching of the wasm failed"}catch(e){P(e)}}function O(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function z(e){for(;e.length>0;)e.shift()(s)}function G(e){try{return b.grow(e-w.byteLength+65535>>>16),A(b.buffer),1}catch(e){}}E(T="tfjs-backend-wasm.wasm")||(B=T,T=s.locateFile?s.locateFile(B,m):m+B);var L=[null,[],[]];function H(e,t){var n=L[e];0===t||10===t?((1===e?y:_)(D(n,0)),n.length=0):n.push(t)}function U(e){return s["_"+e]}function V(e,t,n,a,r){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,a){if(!(a>0))return 0;for(var r=(n>>>=0)+a-1,s=0;s<e.length;++s){var i=e.charCodeAt(s);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),i<=127){if(n>=r)break;t[n++>>>0]=i}else if(i<=2047){if(n+1>=r)break;t[n++>>>0]=192|i>>6,t[n++>>>0]=128|63&i}else if(i<=65535){if(n+2>=r)break;t[n++>>>0]=224|i>>12,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}}t[n>>>0]=0}(e,I,t,n)}(e,t=J(n),n)}return t},array:e=>{var t=J(e.length);return function(e,t){k.set(e,t>>>0)}(e,t),t}};var i=U(e),u=[],o=0;if(a)for(var p=0;p<a.length;p++){var d=s[n[p]];d?(0===o&&(o=Q()),u[p]=d(a[p])):u[p]=a[p]}var l=i.apply(null,u);return function(e){return 0!==o&&Z(o),function(e){return"string"===t?(n=e,(n>>>=0)?D(I,n,void 0):""):"boolean"===t?Boolean(e):e;var n}(e)}(l)}var j={abort:function(){P("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){I.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n=I.length,a=4294901760;if((e>>>=0)>a)return!1;for(var r=1;r<=4;r*=2){var s=n*(1+.2/r);if(s=Math.min(s,e+100663296),G(Math.min(a,(t=Math.max(e,s))+(65536-t%65536)%65536)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,a,r){return 70},fd_write:function(e,t,n,a){for(var r=0,s=0;s<n;s++){var i=S[t>>>2],u=S[t+4>>>2];t+=8;for(var o=0;o<u;o++)H(e,I[i+o>>>0]);r+=u}return S[a>>>2]=r,0}};!function(){var e={env:j,wasi_snapshot_preview1:j};function t(e,t){var n,a=e.exports;s.asm=a,A((b=s.asm.memory).buffer),s.asm.__indirect_function_table,n=s.asm.__wasm_call_ctors,x.unshift(n),function(){if(N--,s.monitorRunDependencies&&s.monitorRunDependencies(N),0==N&&R){var e=R;R=null,e()}}()}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||l)){if("function"==typeof fetch&&!W(T))return fetch(T,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+T+"'";return e.arrayBuffer()})).catch((function(){return $(T)}));if(u)return new Promise((function(e,t){u(T,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return $(T)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){_("failed to asynchronously prepare wasm: "+e),P(e)}))}if(N++,s.monitorRunDependencies&&s.monitorRunDependencies(N),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(e){_("Module.instantiateWasm callback failed with error: "+e),a(e)}(g||"function"!=typeof WebAssembly.instantiateStreaming||E(T)||W(T)||c||"function"!=typeof fetch?r(n):fetch(T,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return _("wasm streaming compile failed: "+e),_("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var q,K,X,Q=s.stackSave=function(){return(Q=s.stackSave=s.asm.stackSave).apply(null,arguments)},Z=s.stackRestore=function(){return(Z=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},J=s.stackAlloc=function(){return(J=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};function Y(e){function t(){q||(q=!0,s.calledRun=!0,M||(z(x),n(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)e=s.postRun.shift(),F.unshift(e);var e;z(F)}()))}N>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)e=s.preRun.shift(),v.unshift(e);var e;z(v)}(),N>0||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t()))}if(s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=function(e,t,n,a){var r=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&r&&!a?U(e):function(){return V(e,t,n,arguments)}},R=function e(){q||Y(),q||(R=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(Y(),r&&(K={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!r.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!r.unhandledRejection.indexOf(e)>-1}))}),void 0!==e)X=e;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");X=WasmBackendModuleThreadedSimd}if(K){var ee=X._dispose;X._dispose=function(){ee(),K.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),K.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});e.exports=n}(tfjsBackendWasm$1);var tfjsBackendWasmExports=tfjsBackendWasm$1.exports,tfjsBackendWasm=getDefaultExportFromCjs(tfjsBackendWasmExports),wasmFactory_import=_mergeNamespaces({__proto__:null,default:tfjsBackendWasm},[tfjsBackendWasmExports]);const wasmFactoryThreadedSimd=tfjsBackendWasmThreadedSimd||wasmFactoryThreadedSimd_import,wasmFactory=tfjsBackendWasm||wasmFactory_import;class BackendWasm extends KernelBackend{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(threadsCount),actualThreadsCount=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new DataStorage(this,engine())}write(e,t,n){const a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=util.now();return e(),{kernelMs:util.now()-t}}move(e,t,n,a,r){const s=this.dataIdNextNumber++;if("string"===a){const i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:a,memoryOffset:null,refCount:r})}const i=util.sizeFromShape(n),u=i*util.bytesPerElement(a),o=this.wasm._malloc(u)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:o,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,o),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),o)}async read(e){return this.readSync(e)}readSync(e,t,n){const{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===r)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||util.sizeFromShape(s);const u=util.bytesPerElement(r);return typedArrayFromBuffer(this.wasm.HEAPU8.slice(a+t*u,a+n*u).buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){const t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(null==n)r=this.write(null!=a?a:null,e,t);else{const a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});const s=util.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){const a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=util.sizeFromShape(e);switch(t){case"float32":return new Float32Array(a,r,s);case"int32":return new Int32Array(a,r,s);case"bool":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}}function createInstantiateWasmFunc(e){return(t,n)=>(util.fetch(e,{credentials:"same-origin"}).then((a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}function getPathToWasmBinary(e,t,n){if(null!=wasmPath)return wasmPath;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),null!=wasmFileMap&&null!=wasmFileMap[a]?wasmFileMap[a]:n+a}async function init(){const[e,t]=await Promise.all([env().getAsync("WASM_HAS_SIMD_SUPPORT"),env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,a)=>{const r={locateFile:(n,a)=>{if(n.endsWith(".worker.js")){const e=wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?getPathToWasmBinary(e,t,null!=wasmPathPrefix?wasmPathPrefix:a):a+n}};customFetch&&(r.instantiateWasm=createInstantiateWasmFunc(getPathToWasmBinary(e,t,null!=wasmPathPrefix?wasmPathPrefix:"")));let s,i=!1;r.onAbort=()=>{i||initAborted||(initAborted=!0,a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==wasmPath?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+wasmFactoryThreadedSimd.toString()],{type:"text/javascript"}),s=wasmFactoryThreadedSimd(r)):s=wasmFactory(r),s.then((e=>{i=!0,initAborted=!1,e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(a)}))}function typedArrayFromBuffer(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}const wasmBinaryNames=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let wasmPath=null,wasmPathPrefix=null,wasmFileMap={},initAborted=!1,customFetch=!1;function setWasmPath(e,t=!1){if(deprecationWarn("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");wasmPath=e,customFetch=t}function setWasmPaths(e,t=!1){if(initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)wasmPathPrefix=e;else{wasmFileMap=e;const t=wasmBinaryNames.filter((e=>null==wasmFileMap[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}customFetch=t}let threadsCount=-1,actualThreadsCount=-1;function setThreadsCount(e){threadsCount=e}function getThreadsCount(){if(-1===actualThreadsCount)throw new Error("WASM backend not initialized.");return actualThreadsCount}const version="4.20.0",WASM_PRIORITY=2;registerBackend("wasm",(async()=>{const{wasm:e}=await init();return new BackendWasm(e)}),2);export{BackendWasm,getThreadsCount,setThreadsCount,setWasmPath,setWasmPaths,version as version_wasm};